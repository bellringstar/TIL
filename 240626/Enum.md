## Enum
enum은 여러 상수를 하나의 그룹으로 묶어 사용할 수 있도록 하는 데이터 타입이다. 이를 통해 코드의 가독성을 높이고 타입 안전성을 제공하며 고정된 상수 집합을 정의하는데 매우 유용하다.
### Enum의 생성 원리
enum은 자바 컴파일러에 의해 특정한 클래스로 변환된다. 이 과정에서 각 'enum'상수는 **고유한 인스턴스**로 생성된다. enum은 암묵적으로
java.lang.Enum 클래스를 상속받으며 컴파일러는 추가적인 메서드와 필드를 자동으로 생성한다.
### Enum의 내부 구조
- 상수필드<br>
enum의 각 상수는 public static final 필드로 선언된다.
- 생성자<br>
enum의 생성자는 기본적으로 private이며, 각 상수는 이 생성자를 통해 초기화된다.
- 내부 배열<br>
enum의 모든 상수는 내부 배열에 저장되며 values()메서드는 이 배열을 반환한다.
- 내부 메서드<br>
name()이나 ordinal()같은 메서드를 제공하는데 이는 Enum클래스로 부터 상속받은 것이다.
- values() 메서드<br>
모든 enum상수를 배열로 반환하는 values() 메서드가 자동으로 생성된다.
### 상수별 메서드 구현 기능
enum에서는 추상 메서드를 작성하고 상수별로 override를 해 서로 다른 메서드를 구현할 수 있다. 참고로 enum은 인터페이스를 구현 할 수도 있다.
### EnumSet과 EnumMap
- EnumSet<br>
고효율의 enum 집합니다. 내부적으로 Bit Vector를 사용해 enum상수의 집합을 표현한다.<br>
enum이 고정된 집합이라는 점을 이용하여 비트 벡터를 사용해 각 상수의 존재여부를 비트 플래그로 저장한다. 예를 들어
enum이 64개의 상수를 가진다면, 단 하나의 long값을 사용하여 모든 상수의 존재 여부를 표현할 수 있다. 또한 비트벡터를 사용하면
상수의 추가, 삭제, 포함 여부 확인 등의 연산이 비트 연산으로 매우 빠르게 수행된다. 상수의 순회도 비트 벡터를 순회하며 상수가 있는 비트를
찾는 방식으로 효율적으로 수행된다.
- EnumMap<br>
고효율의 enum 맵이다. enum을 키로 사용하며 내부적으로 배열을 사용하여 enum상수에 대한 값을 저장한다.<br>
EnumMap은 enum상수의 고정된 개수를 알고 있기 때문에, 내부적으로 배열을 사용하여 각 상수에 대한 값을 저장한다. 이는 해시기반 Map보다
메모리 사용이 효율적이다.
배열의 인덱스를 enum의 ordinal 값을 사용하여 직접 접근할 수 있기 때문에 메모리 낭비가 적다.
또한 배열을 사용하므로 키에 대한 접근이 O(1)로 매우 빠르며 해시충돌이 없으므로 해시 기반 Map과 달리 해시 충돌 처리 비용이 없다.

이 두 자료구조는 일반 set과 map에 enum을 사용하는 것에 비해 메모리 사용과 성능면에서 매유 효율적이다.<br>
여기서 드는 의문점이 두 가지 있다.
1. 비트벡터가 뭐지<br>
비트벡터란 비트의 배열을 사용하여 데이터를 압축하여 저장하는 자료구조다. 각 비트는 두가지 상태(0 또는 1)을 가지며 특정 조건을 나타내는 데 사용될 수 있다.
비트벡터는 주로 집합과 같은 데이터르 효율적으로 저장하고 처리하는 데 사용된다.<br>
예를 들어 RED, GREEN, BLUE, YELLOW, PURPLE 의 enum이 있을 때 Color.RED와 Color.BLUE가 선택되었음을 나타내기 위해
00101의 비트벡터를 이용할 수 있다.
2. Ordinal을 통해 배열의 인덱스에 직접 접근할 수 있다는데 사용중에 순서를 변경해 ordinal이 바뀐다면 어떻게 되지
<br> RED, GREEN, BLUE가 있을 때 colorMap은 내부적으로 다음과 같이 저장된다.

| Index | 0    | 1      | 2     |
|-------|------|--------|-------|
| Color | RED  | GREEN  | BLUE  |
| Value | "Red" | "Green" | "Blue" |
RED의 ordinal이 0이므로 배열의 0번 인덱스에 저장되는 형식이다. 이 상황에서 갑자기 Enum의 상수 순서를 바꿔 ordinal이 변경된다면 어떻게 될까?
이는 EnumMap의 동작이 달라져 잘못된 매핑을 초래할 수 있다. 이는 ordinal값을 기반으로 배열에 데이터를 저장하기 때문에 발생하는 문제이다.<br>
여기서 상수 순서를 BLUE, GREEN, RED로 변경하게 되면 RED의 ordinal은 2로 변경되고 colorMap.get(Color.RED)를 하여도 null이 반환된다.
<br>이를 피하기 위해서는 ordinal변경을 최대한 피하고 별도의 인덱스 필드를 넣어 커스텀으로 Map을 만들어 사용하는 방법이 있다.

### Enum의 직렬화
enum은 자동적으로 직렬화 및 역질렬화를 지원한다. enum상수는 이름으로 직렬화 되며, 역직렬화할 때는 이름으로 해당 상수를 찾아 반환한다.
### Enum의 메모리 사용과 성능
enum은 정적 필드로 선언되기 때문에 클래스 로딩 시점에서 메모리에 로드된다. 따라서 enum상수의 생성비용은 한 번만 지불되며, 
이후에는 빠르게 접근할 수 있다. 이는 메모리 효율적이며, 성능 측면에서도 매우 유리하다.
## 일급컬렉션의 사용
