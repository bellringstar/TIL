## Enum
enum은 여러 상수를 하나의 그룹으로 묶어 사용할 수 있도록 하는 데이터 타입이다. 이를 통해 코드의 가독성을 높이고 타입 안전성을 제공하며 고정된 상수 집합을 정의하는데 매우 유용하다.
### Enum의 생성 원리
enum은 자바 컴파일러에 의해 특정한 클래스로 변환된다. 이 과정에서 각 'enum'상수는 **고유한 인스턴스**로 생성된다. enum은 암묵적으로
java.lang.Enum 클래스를 상속받으며 컴파일러는 추가적인 메서드와 필드를 자동으로 생성한다.
### Enum의 내부 구조
- 상수필드<br>
enum의 각 상수는 public static final 필드로 선언된다.
- 생성자<br>
enum의 생성자는 기본적으로 private이며, 각 상수는 이 생성자를 통해 초기화된다.
- 내부 배열<br>
enum의 모든 상수는 내부 배열에 저장되며 values()메서드는 이 배열을 반환한다.
- 내부 메서드<br>
name()이나 ordinal()같은 메서드를 제공하는데 이는 Enum클래스로 부터 상속받은 것이다.
- values() 메서드<br>
모든 enum상수를 배열로 반환하는 values() 메서드가 자동으로 생성된다.
### 상수별 메서드 구현 기능
enum에서는 추상 메서드를 작성하고 상수별로 override를 해 서로 다른 메서드를 구현할 수 있다. 참고로 enum은 인터페이스를 구현 할 수도 있다.
### EnumSet과 EnumMap
- EnumSet<br>
고효율의 enum 집합니다. 내부적으로 Bit Vector를 사용해 enum상수의 집합을 표현한다.<br>
enum이 고정된 집합이라는 점을 이용하여 비트 벡터를 사용해 각 상수의 존재여부를 비트 플래그로 저장한다. 예를 들어
enum이 64개의 상수를 가진다면, 단 하나의 long값을 사용하여 모든 상수의 존재 여부를 표현할 수 있다. 또한 비트벡터를 사용하면
상수의 추가, 삭제, 포함 여부 확인 등의 연산이 비트 연산으로 매우 빠르게 수행된다. 상수의 순회도 비트 벡터를 순회하며 상수가 있는 비트를
찾는 방식으로 효율적으로 수행된다.
- EnumMap<br>
고효율의 enum 맵이다. enum을 키로 사용하며 내부적으로 배열을 사용하여 enum상수에 대한 값을 저장한다.<br>
EnumMap은 enum상수의 고정된 개수를 알고 있기 때문에, 내부적으로 배열을 사용하여 각 상수에 대한 값을 저장한다. 이는 해시기반 Map보다
메모리 사용이 효율적이다.
배열의 인덱스를 enum의 ordinal 값을 사용하여 직접 접근할 수 있기 때문에 메모리 낭비가 적다.
또한 배열을 사용하므로 키에 대한 접근이 O(1)로 매우 빠르며 해시충돌이 없으므로 해시 기반 Map과 달리 해시 충돌 처리 비용이 없다.

이 두 자료구조는 일반 set과 map에 enum을 사용하는 것에 비해 메모리 사용과 성능면에서 매유 효율적이다.<br>
여기서 드는 의문점이 두 가지 있다.
1. 비트벡터가 뭐지<br>
비트벡터란 비트의 배열을 사용하여 데이터를 압축하여 저장하는 자료구조다. 각 비트는 두가지 상태(0 또는 1)을 가지며 특정 조건을 나타내는 데 사용될 수 있다.
비트벡터는 주로 집합과 같은 데이터르 효율적으로 저장하고 처리하는 데 사용된다.<br>
예를 들어 RED, GREEN, BLUE, YELLOW, PURPLE 의 enum이 있을 때 Color.RED와 Color.BLUE가 선택되었음을 나타내기 위해
00101의 비트벡터를 이용할 수 있다.
2. Ordinal을 통해 배열의 인덱스에 직접 접근할 수 있다는데 사용중에 순서를 변경해 ordinal이 바뀐다면 어떻게 되지
<br> RED, GREEN, BLUE가 있을 때 colorMap은 내부적으로 다음과 같이 저장된다.

| Index | 0    | 1      | 2     |
|-------|------|--------|-------|
| Color | RED  | GREEN  | BLUE  |
| Value | "Red" | "Green" | "Blue" |
RED의 ordinal이 0이므로 배열의 0번 인덱스에 저장되는 형식이다. 이 상황에서 갑자기 Enum의 상수 순서를 바꿔 ordinal이 변경된다면 어떻게 될까?
이는 EnumMap의 동작이 달라져 잘못된 매핑을 초래할 수 있다. 이는 ordinal값을 기반으로 배열에 데이터를 저장하기 때문에 발생하는 문제이다.<br>
여기서 상수 순서를 BLUE, GREEN, RED로 변경하게 되면 RED의 ordinal은 2로 변경되고 colorMap.get(Color.RED)를 하여도 null이 반환된다.
<br>이를 피하기 위해서는 ordinal변경을 최대한 피하고 별도의 인덱스 필드를 넣어 커스텀으로 Map을 만들어 사용하는 방법이 있다.

### Enum의 직렬화
enum은 자동적으로 직렬화 및 역질렬화를 지원한다. enum상수는 이름으로 직렬화 되며, 역직렬화할 때는 이름으로 해당 상수를 찾아 반환한다.
### Enum의 메모리 사용과 성능
enum은 정적 필드로 선언되기 때문에 클래스 로딩 시점에서 메모리에 로드된다. 따라서 enum상수의 생성비용은 한 번만 지불되며, 
이후에는 빠르게 접근할 수 있다. 이는 메모리 효율적이며, 성능 측면에서도 매우 유리하다.
## 일급컬렉션의 사용
## Req-Saver를 사용한 Thundering Herd 문제 해결
https://techblog.lycorp.co.jp/ko/req-saver-for-thundering-herd-problem-in-cache </br>
Thundering Herd 캐시를 사용할 때 발생할 수 있는 문제이다.
기본적으로 캐시의 사용은 다음의 흐름을 따른다.<br>
클라이언트가 요청을 했을 때 그에 맞는 내용이 캐시에 있으면 케시에 있다면 바로 응답을 받고 캐시에 존재하지 않는다면 백엔드의 데이터 스토어에서 데이터를 가져와
캐시에 저장하고 클라이언트에 응답해준다.<br>
하지만 N개의 클라이언트가 동일한 데이터 요청을 동시에 했다고 가정해보자. 그러면 현재 케시에 없는 상태이기 때문에 N번의 요청이 모두 DB로 요청이 들어가게 되고 또 일반적인 
경우 캐시에도 N번의 저장이 실행된다. 이는 DB와 캐시 모두에 부하를 일으키는 원인이 되며 이를 'Thundering Herd'문제라고 한다.

### Req-Saver가 이 문제를 해결하는 아이디어
Req-Saver는 이러한 문제를 다음의 아이디어로 해결하고 있다.<br>
- 요청받은 데이터가 캐시에 없는 경우
  - Lock의 아이디어를 채용하고 있다. 캐시에 없다면 특정 요청만 백엔드 저장소로 요청을 보내고 나머지 요청은 락을 걸어 캐시에 데이터가 생성될 때 까지 기다린다.
- 요청받은 데이터가 캐시에 있는 경우
  - 이 경우는 미래를 위한 예방이다. 예를들어 TTL이 10초인데 클라이언트가 해당 캐시를 조회할 때 TTL이 2초정도 남은 시점이라면 만료를 기다리는게 아니라 바로 캐시를 갱신하는 것이다.
  이렇게 하면 일정한 트래픽이 들어온다는 전제하에 캐시가 만료되는 공백 시간 없이 마치 캐시가 연속적으로 존재하는 것과 같은 효과를 기대할 수 있다.

### Req-Saver는 이 아이디어들을 어떻게 구현했는가
- 요청받은 데이터가 캐시에 존재하지 않을 때
  - 글로벌락<br>
    글로벌락은 라이브러리 입장에서는 개발자가 어떤 분산락을 사용할지 모르기 때문에 단순히 함수를 주입받는 방식으로 구현했다.
    개발자가 Req-Saver의 인스턴스를 생성할 때 주입한 글로벌 락 함수를 애플리케이션단에서 실행함으로써 글로벌 락을 취득했다고 인식한 후,
    락을 취득한 요청이 대표로 데이터 취득 및 캐시 적재 작업을 진행한다.
  - 로컬락<br>
    세마포어를 적극 사용하고 있다. 락 취득이 서버 인스턴스마다 진행된다.
- 요청받은 데이터가 캐시에 존재할 때
  - 우선 케시에 데이터가 존재하기 때문에 락을 얻지 못한 요청들도 기다릴 필요가 없이 바로 응답을 하면 된다. 락을 취득한 요청
  역시 바로 응답하며 비동기로 캐시 갱신을 진행한다.
## 함수형 인터페이스 
## Comparator
## Git의 동작
