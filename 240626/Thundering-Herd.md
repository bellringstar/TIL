## Req-Saver를 사용한 Thundering Herd 문제 해결
https://techblog.lycorp.co.jp/ko/req-saver-for-thundering-herd-problem-in-cache </br>
Thundering Herd 캐시를 사용할 때 발생할 수 있는 문제이다.
기본적으로 캐시의 사용은 다음의 흐름을 따른다.<br>
클라이언트가 요청을 했을 때 그에 맞는 내용이 캐시에 있으면 케시에 있다면 바로 응답을 받고 캐시에 존재하지 않는다면 백엔드의 데이터 스토어에서 데이터를 가져와
캐시에 저장하고 클라이언트에 응답해준다.<br>
하지만 N개의 클라이언트가 동일한 데이터 요청을 동시에 했다고 가정해보자. 그러면 현재 케시에 없는 상태이기 때문에 N번의 요청이 모두 DB로 요청이 들어가게 되고 또 일반적인
경우 캐시에도 N번의 저장이 실행된다. 이는 DB와 캐시 모두에 부하를 일으키는 원인이 되며 이를 'Thundering Herd'문제라고 한다.

### Req-Saver가 이 문제를 해결하는 아이디어
Req-Saver는 이러한 문제를 다음의 아이디어로 해결하고 있다.<br>
- 요청받은 데이터가 캐시에 없는 경우
    - Lock의 아이디어를 채용하고 있다. 캐시에 없다면 특정 요청만 백엔드 저장소로 요청을 보내고 나머지 요청은 락을 걸어 캐시에 데이터가 생성될 때 까지 기다린다.
- 요청받은 데이터가 캐시에 있는 경우
    - 이 경우는 미래를 위한 예방이다. 예를들어 TTL이 10초인데 클라이언트가 해당 캐시를 조회할 때 TTL이 2초정도 남은 시점이라면 만료를 기다리는게 아니라 바로 캐시를 갱신하는 것이다.
      이렇게 하면 일정한 트래픽이 들어온다는 전제하에 캐시가 만료되는 공백 시간 없이 마치 캐시가 연속적으로 존재하는 것과 같은 효과를 기대할 수 있다.

### Req-Saver는 이 아이디어들을 어떻게 구현했는가
- 요청받은 데이터가 캐시에 존재하지 않을 때
    - 글로벌락<br>
      글로벌락은 라이브러리 입장에서는 개발자가 어떤 분산락을 사용할지 모르기 때문에 단순히 함수를 주입받는 방식으로 구현했다.
      개발자가 Req-Saver의 인스턴스를 생성할 때 주입한 글로벌 락 함수를 애플리케이션단에서 실행함으로써 글로벌 락을 취득했다고 인식한 후,
      락을 취득한 요청이 대표로 데이터 취득 및 캐시 적재 작업을 진행한다.
    - 로컬락<br>
      세마포어를 적극 사용하고 있다. 락 취득이 서버 인스턴스마다 진행된다.
- 요청받은 데이터가 캐시에 존재할 때
    - 우선 케시에 데이터가 존재하기 때문에 락을 얻지 못한 요청들도 기다릴 필요가 없이 바로 응답을 하면 된다. 락을 취득한 요청
      역시 바로 응답하며 비동기로 캐시 갱신을 진행한다.
      사용 : 자바 8에서 제공하는 표준 함수형 인터페이스를 최대한 활용하여 코드의 일관성을 유지하는 것이 좋습니다.
