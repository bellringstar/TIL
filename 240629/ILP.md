# ILP(Instruction-Level Parallelism)
명령어 수준 병렬성(ILP)는 현대 컴퓨터 아키텍처의 핵심 개념 중 하나입니다. 왜 ILP가 중요할까요?<br>
그 이유는 단순합니다. CPU의 성능을 극대화하기 위해서입니다.
## 왜 ILP가 필요한가?
1. CPU클럭 속도 한계 극복
- 물리적 한계로 인해 단순히 클럭 속도를 높이는 것만으로는 성능 향상에 제한이 있습니다.
2. 자원 활용도 증가
- CPU의 여러 실행 유닛을 동시에 활용하여 처리량을 증가시킵니다.
3. 명령어 지연 시간 감소
- 메모리 접근 등으로 인한 지연 시간을 다른 명렁어 실행으로 가려 전체적인 성능을 향상시킵니다.
## ILP의 기본 원리
ILP는 여러 명령어를 동시에 또는 순서를 바꿔 실행함으로써 성능을 향상시킵니다.
### 명령어 파이프라이닝(Pipelining)
파이프 라이닝은 명령어 실행 화정을 여러 단계로 나누고, 각 단계를 병렬로 처리하는 기법입니다.
```markdown
단순한 파이프라인 예시:
IF   ID   EX   MEM   WB
|    |    |    |     |
IF   ID   EX   MEM   WB
     |    |    |     |
     IF   ID   EX    MEM   WB
          |    |     |     |
          IF   ID    EX    MEM   WB

IF: Instruction Fetch
ID: Instruction Decode
EX: Execute
MEM: Memory Access
WB: Write Back
```
- 장점
  - 여러 명령어를 동시에 처리하여 처리량(throughput)증가
  - 각 단계의 하드웨어를 효율적으로 활용
- 단점
  - 파이프라인 해저드 발생 가능
    - 데이터 해저드 : 명령어 간 데이터 의존성
    - 제어 해저드 : 분기 명령어로 인한 흐름 변경
    - 구조적 해저드 : 하드웨어 자원 충돌
### 슈퍼 스칼라(Superscalar)
슈퍼스칼라 아키텍처는 여러 개의 파이프라인을 병렬로 사용하여 동시에 여러 명령어를 실행합니다.
```markdown
슈퍼스칼라 파이프라인 예시:
IF1  ID1  EX1  MEM1  WB1
|    |    |    |     |
IF2  ID2  EX2  MEM2  WB2
|    |    |    |     |
IF1  ID1  EX1  MEM1  WB1
|    |    |    |     |
IF2  ID2  EX2  MEM2  WB2
```
- 장점
  - 파이프라이닝보다 더 높은 명령어 처리량 달성
  - 다양한 유형의 명령어를 동시에 처리 가능
- 단점
  - 하드웨어 복잡도 증가
  - 명령어 간 의존성 처리가 더 어려워짐
### 비순차적 명령어 처리(Out-of-Order Execution)
비순차적 실행은 명령어의 원래 순서와 상관없이, 실행 가능한 명령어를 먼저 처리하는 기법입니다.
```markdown
# 원래 코드
a = b + c  # 1
d = e + f  # 2
g = a * d  # 3

# 비순차적 실행
d = e + f  # 2 (1번 명령어와 독립적이므로 먼저 실행 가능)
a = b + c  # 1
g = a * d  # 3
```
- 장점
  - 명령어 지연으로 인한 파이프라인 정지를 최소화
  - 자원 활용도 증가
- 단점
  - 하드웨어 구현이 매우 복잡
  - 재배치로 인한 부작용 방지 로직 필요
### 분기 예측(Branch Prediction)
분기 예측은 조건문의 결과를 미리 예측하여 파이프라인을 계속 채우는 기법입니다.
```markdown
if (condition) {
    // 분기 예측기가 이 부분을 실행할 것이라 예측
    // 예측이 맞으면 계속 실행, 틀리면 파이프라인 플러시
} else {
    // 예측이 틀렸을 경우 이 부분 실행
}
```
- 장점
  - 조건문으로 인한 파이프라인 정지 최소화
  - 예측이 정확할 경우 큰 성능 향상
- 단점
  - 예측이 틀릴 경우 파이프라인 플러시로 인한 성능 저하
  - 복잡한 예측 알고리즘 필요
## ILP의 한계와 미래
ILP는 놀라운 성능 향상을 가져왔지만 몇 가지 한계점이 있습니다.
1. 명령어 수준 병렬성의 한계 : 프로그램 자체의 의존성으로 인한 제약
2. 전력 소비 : 복잡한 하드웨어로 인한 높은 전력 소비
3. 복잡도 증가 : 성능 향상 대비 하드웨어 복잡도 급증
<br> 이러한 한계를 극복하기 위해, 현대 프로세서 설계는 다음과 같은 방향으로 진화하고 있습니다.
- 멀티코어 및 매니코어 아키텍처: 스레드 수준 병렬성(TLP) 활용
- 특화된 가속기 : GPU, TPU등 특정 연산에 최적화된 프로세서
- 새로운 컴퓨팅 패러다임: 양자 컴퓨팅, 뉴로모픽 컴퓨팅등
