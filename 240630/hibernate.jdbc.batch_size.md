# hibernate.jdbc.batch_size : 데이터베이스 잡업의 효율성을 높이는 핵심 설정
## hibernate.jdbc.batch_size란?
hibernate.jdbc.batch_size는 Hibernate가 데이터베이스로 보내는 SQL 문을 그룹화하는 크기를 지정하는 설정입니다.
 이 설정을 통해 Hibernate는 여러 개의 SQL 문을 하나의 배치로 묶어 데이터베이스로 전송할 수 있스빈다.
## 왜 이 설정을 사용하나요?
1. 성능 향상 : 여러 SQL 문을 한 번에 전송함으로써 데이터베이스 왕복 횟수를 줄일 수 있습니다.
2. 네트워크 부하 감소 : 데이터베이스와 애플리케이션 사이의 네트워크 트래픽을 줄일 수 있습니다.
3. 데이터베이스 리소스 효율성 : 데이터베이스가 여러 요청을 한 번에 처리할 수 있어 리소스 사용이 효율적입니다.
## 동작 원리
1. 쓰기 지연(Write-Behind) 메커니즘
- Hibernate는 엔티티의 변경사항을 즉시 데이터베이스에 반영하지 않고 일차적으로 영속성 컨텍스트에 저장합니다.
- 이 영속성 컨텍스트 내에는 쓰기 지연 저장소가 있어 변경 사항을 임시로 보관합니다.
2. 배치 크기에따른 SQL 그룹화
- hibernate.jdbc.batch_size 옵션은 이 쓰기 지연 저장소에 얼마나 많은 SQL 문을 모을지 결정합니다.
- 예를 들어 batch_size가 30으로 설정되면 Hibernate는 최대 30개의 같은 종류의 SQL문(예: INSERT)을 그룹화 합니다.
3. Flush 시점
- 트랜잭션이 커밋되거나 명시적으로 flush()를 호출하거나, 쿼리 실행 전 필요한 경우 Hibernate는 쓰기 지연 저장소의 내용을 데이터베이스에 플러시합니다.
- 이 때 그룹화된 SQL 문들이 배치로 실행됩니다.
4. JDBC 배치 API 사용
- Hibernate는 내부적으로 JDBC의 배치 처리 API를 사용합니다.
- PreparedStatement의 addBatch()와 executeBatch() 메서드를 이용해 배치 처리를 수행합니다.
5. 동일 타입 SQL 문 그룹화
- Hibernate는 같은 타입의 SQL 문들만 배치로 그룹화합니다.
- 예를 들어 INSERT 문들끼리, UPDATE 문들끼리 그룹화됩니다.
## 어떻게 설정하나요?
```properties
spring.jpa.properties.hibernate.jdbc.batch_size=30
```
## 주의할 점
1. 적절한 크기 선택 : 너무 작으면 효과가 미미하고, 너무 크면 메모리 사용량이 증가할 수 있습니다.
2. order_inserts와 order_updates: 이 설정들과 함께 사용하면 더 효과적입니다.
- hiberante.order_inserts: true로 설정하면 Hibernate가 insert 문을 재정렬하여 같은 형태의 insert문을 그룹화합니다.
- hibernate.order_updates: true로 설정하면 Hibernate가 update문을 재정렬하여 같은 형태의 update 문을 그룹화합니다.
- 이를 통해 같은 테이블에 대한 작업들을 그룹화 하여 더 효율적인 배치 처리가 가능합니다.
- 데이터베이스가 같은 형태의 SQL 문을 연속해서 처리할 수 있어 성능이 향상됩니다.
- 이 옵션에 대해 자세히 살펴보겠습니다.
  - 기본적으로 Hibernate는 엔티티가 변경된 순서대로 SQL을 생성합니다.
  - order_inserts와 order_updates의 역할
    - SQL 재정렬 : 같은 테이블에 대한 작업들을 그룹화합니다.
    - 효율성 증가 : 데이터베이스가 유사한 쿼리를 연속해서 처리할 수 있어 성능이 향상됩니다.
- 그러면 항상 키는게 좋은거 아닌가?
  - 단점이 존재합니다.
  - 메모리 사용량 증가
    - 재정렬을 위해 메모리에 더 많은 정보를 유지해야 합니다.
    - 대량의 데이터를 처리할 때 이 메모리 사용량이 문제가 될 수 있습니다.
  - 순서 의존성 문제
    - 애플리케이션 로직이 특정 순서로 데이터가 삽입/수정되는 것에 의존한다면 문제가 발생할 수 있습니다.
    - 예를 들어 외래 키 관계가 있는 엔티티들을 특정 순서로 저장해야 하는 경우 문제가 될 수 있스빈다.
  - 트랜잭션 격리 수준 영향
    - 높은 트랜잭션 격리 수준에서는 재정렬로 인해 예상치 못한 동시성 문제가 발생할 수 있습니다.
  - 디버깅 어려움
    - SQL 실행 순서가 코드 실행 순서와 다르기 떄문에 디버깅이 더 복잡해질 수 있습니다.
  - 특정 데이터베이스 기능과의 충돌
3. 트랜잭션 범위 : 배치 작업은 같은 트랜잭션 내에서만 동작합니다.
4. 서로 다른 종류의 SQL문 사이에서는 자동으로 플러시가 발생할 수 있습니다. 
예를 들어 INSERT 후 UPDATE를 수행하면 INSERT 배치가 먼저 실행됩니다.
5. 일부 상황(ID 생성 전략 등)에서는 배치 처리과 효과적으로 동작하지 않을 수 있습니다.
## 사용 예시
```java
public class test {
    
    private EntityManager entityManager;
    
    @Transactional
    public void batchInsert() {
        for (int i = 0; i < 100; i++) {
            User user = new User("user" + i);
            entityManager.persist(user);
        }
        
        if (i % 30 == 0 && i > 0) {
            entityManager.flush();
            entityManager.cleat();
        }
    }
}
```
이 예제에서는 30개의 insert문이 하나의 배치로 처리됩니다.
### 성능 영향
배치 크기를 적절히 선택하면 성능 향사을 볼 수 있습니다. 예를 들어 10,000개의 엔티티를 삽입하는 경우
- 배치 없이 : 약 10,000번의 데이터베이스 왕복
- 배치 크기 30 : 약 334번의 데이터베이스 왕복
## 주의사항 및 팁
- 모든 작업에 적용되지 않음 : auto-commit 모드에서는 배치 처리가 작동하지 않습니다.
- 데이터베이스 지원 : 일부 데이터베이스는 특정 작업의 배치 처리를 지원하지 않을 수 있습니다.
- 모니터링 : 실제 애플리케이션 성능을 모니터링 하고 최적의 배치 크기를 찾는 것이 중욯바니다.