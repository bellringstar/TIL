# ServerSocket 
## ServerSocket의 동작 원리
### 1. 소켓 생성 및 바인딩
- ServerSocket이 생성될 때, 운영체제는 커널 수준에서 소켓 디스크립터를 할당합니다.
- 이 디스크립터는 네트워크 스택과 상호작용하는 핸들 역할을 합니다. 
- 바인딩 과정에서 이 소켓은 특정 IP 주소와 포트 번호에 연결됩니다.
- 이는 운영체제의 네트워크 스택에 해당 IP:포트로 들어오는 모든 TCP 연결 요청을 이 소켓으로 라우팅하도록 지시합니다.
### 2. Listening 상태
- bind() 호출 후, 소켓은 listen() 시스템 콜을 통해 LISTEN 상태로 전환됩니다.
- 이 상태에서 TCP의 3-way handshake를 위한 SYN 패킷을 받을 수 있게 됩니다.
- backlog 매개변수는 완전히 설정되지 않은 연결(SYN_RCVD 상태)과 accept()를 기다리는 완전히 설정된 연결(ESTABLISHED 상태)의 총 개수를 제한합니다.
### 3. accept() 메서드
- accept()가 호출되면, 프로세스는 블록되고 커널은 완전히 설정된 연결이 있을 때까지 기다립니다.
- 연결이 설정되면, 커널은 새로운 소켓 디스크립터를 생성하고 이를 accept() 호출의 반환값으로 사용합니다.
- 이 새 소켓은 특정 클라이언트 연결에 대응합니다.

## 왜 이런 방식을 사용하는가?
### 1. 분리된 관심사
- ServerSocket과 Socket의 분리는 관심사의 분리 원칙을 반영합니다.
- ServerSocket은 연결 수립에만 집중하고, Socket은 실제 데이터 통신을 담당합니다.
### 2. 효율적인 리소스 관리
- accept()의 블로킹 특성은 CPU 자원을 효율적으로 사용하게 해줍니다.
- 연결 요청이 없을 때 계속해서 CPU를 소모하는 대신, 운영체제가 프로세스를 대기 상태로 전환하여 다른 작업을 수행할 수 있게 합니다.
### 3. 운영체제 레벨의 최적화
- TCP 연결 수립 과정의 많은 부분이 커널 수준에서 처리됩니다.
- 이는 사용자 공간 코드의 복잡성을 줄이고, 운영체제의 네트워크 스택 최적화를 활용할 수 있게 합니다.
### 4. 보안
- accept()의 사용은 각 클라이언트 연결에 대해 새로운 소켓을 생성함으로써 연결 간의 격리를 제공합니다.
- 이는 한 연결의 문제가 다른 연결에 영향을 미치는 것을 방지합니다.
### 5. 확장성
- 이 모델은 멀티스레딩이나 비동기I/O와 쉽게 결합될 수 있습니다.
- 각 accept()된 소켓을 별도의 스레드나 이벤트 루프에 할당함으로써 동시성을 구현할 수 있습니다.

## 주요 특징과 사용법
### 1. 생성자
- ServerSocket(int port): 지정된 포트에 바인딩된 서버 소켓을 생성합니다.
- ServerSocket(int port, int backlog): backlog 매개변수로 연결 대기열의 최대 길이를 지정할 수 있습니다.
- ServerSocket(int port, int backlog, InetAddress bindAddr): 특정 네트워크 인터페이스에 바인딩할 수 있습니다.
### 2. 주요 메서드
- accept(): 클라이언트의 연결을 수락합니다. 이 메서드는 클라이언트가 연결할 때까지 블로킹됩니다.
- close(): 서버 소켓을 닫습니다.
- isClosed(): 서버 소켓이 닫혔는지 확인합니다.
- setSoTimeout(int timeout): accept() 메서드의 타임아웃을 설정합니다.
### 3. 예외 처리
- IOException: 네트워크 오류 발생 시 던져집니다.
- SocketTimeoutException: accept() 메서드에 타임아웃이 설정되었고, 지정된 시간 내에 연결이 수락되지 않았을 때 발생합니다.
### 4. 보안
- setReuseAddress(boolean on): 소켓의 SO_REUSEADDR 옵션을 설정합니다. 이는 이전에 사용되던 포트를 즉시 재사용할 수 있게 해줍니다.
### 5. 성능
- setReceiveBufferSize(int size): 수신 버퍼의 크기를 설정합니다.

## 궁금증
### 블로킹은 어느 시점에서 발생하는가?
- ServerSocket의 생성 시점에서는 blocking이 발생하는게 아니다. 이 시점은 그저 연결을 받을 준비를 하고 있는 것이다.
- 그 후 accept() 메서드가 호출이 되는 순간부터 블로킹이 시작된다.
- 이 시점에서 서버는 클라이언트의 연결을 기다리며 대기 상태가 된다.
- 클라이언트가 해당 서버와 포트로 연결을 시도하고 3-way handshake를 거쳐 연결 요청이 서버에 도달하면 운영체제 수준에서 연결을 수립한다.
- 연결이 수립되면 accpet() 메서드가 Socket 객체를 생성해 반환한다. -> 이 시점에서 블로킹이 해제되고 다음 라인으로 진행이 된다.
- 즉 accept() 메서드는 대기하고 있다가 클라이언트의 연결 요청이 완료되었음을 서버에 알리는 것이다.
- 이 메서드가 반환하는 Socket 객체는 특정 클라이언트와의 연결을 나타내는 것이다.
### accept() 메서드가 Socket을 리턴하면 그 Socket을 별도의 스레드에서 처리하는게 일반적이라는데..
accept() 자체를 별도의 스레드에서 처리하는 것과 무슨 차이가 있을까?
1. accept()로 반환된 Socket을 다른 스레드에 전달하는 방식
- 구조
  - 메인 스레드: accept() 호출
  - 워커 스레드: 반환된 Socket으로 클라이언트 요청 처리
- 동작 과정
  - 메인 스레드가 accept() 호출하고 대기
  - 연결이 수립되면 Socket 객체 반환
  - 메인 스레드가 워커 스레드에 Socket 전달
  - 워커 스레드가 클라이언트 요청 처리
  - 메인 스레드는 다시 accept() 호출
- 장점
  - 연결 수립과 요청 처리가 명확하게 분리됨
  - 메인 스레드가 연결 수립에만 집중할 수 있어 효율적
  - 연결 수립 속도가 빠름
- 단점
  - 구현이 약간 더 복잡할 수 있다.
2. accept() 자체를 다른 스레드에서 실행하는 방식
- 구조
  - 여러 스레드가 각각 accept() 호출
- 동작 과정
  - 여러 스레드가 동시에 accept()를 호출하고 대기
  - 연결이 수립되면 그 중 한 스레드의 accept()가 반환
  - 해당 스레드가 직접 클라이언트 요청 처리
  - 처리 완료 후 다시 accept() 호출
- 장점
  - 상대적으로 구현이 간단할 수 있음
  - 각 스레드가 연결 수립부터 요청 처리까지 담당하여 독립적
- 단점
  - 여러 스레드가 동시에 accept()를 호출하면 경쟁 조건 발생
  - 운영체제에 따라 thundering herd 문제 발생 가능
  - 연결 수립과 요청 처리가 결합되어 유연서잉 떨어짐
<br>

생각해보니 스레드별로 accept()를 호출하면 스레드풀의 모든 스레드가 연결 대기 상태로 블로킹이 될 수 있겠다.<br>
결국 스레드풀의 이점을 제대로 활용하지 못하게 된다.