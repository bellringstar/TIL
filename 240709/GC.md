# Garbage Collection
GC는 프로그래밍 언어 런타임 환경에서 사용되지 않는 메모리를 자동으로 회수하는 메모리 관리 기법입니다.
GC는 메모리 누수를 방지하고, 프로그래머가 메모리 관리를 직접 수행해야 하는 부담을 줄입니다.

## GC가 필요한 이유
- 메모리 누수 방지
  - 메모리를 더 이상 사용하지 않지만 해제되지 않은 객체가 계속해서 메모리를 차지하는 상황을 방지합니다.
- 자동화된 메모리 관리
  - 프로그래머가 메모리를 직접 할당하고 해제해야 하는 번거로움을 줄여주며, 코드의 안정성과 신뢰성을 높입니다.
- 성능 최적화
  - 메모리 관리가 자동으로 이루어지므로, 메모리 관련 버그를 줄이고, 애플리케이션의 성능을 최적화 할 수 있습니다.

## GC의 동작 방식
### Mark-and-Sweep 알고리즘
1. 마킹 단계: 모든 객체 그래프를 탐색하여 현재 사용 중인 객체를 식별하고 마킹합니다.
2. 스위프 단계: 마킹되지 않은 객체를 메모리에서 제거하고, 해제된 메모리를 재사용할 수 있도록 합니다.
- 장점: 간단하고 이해가기 쉬운 알고리즘입니다.
- 단점: 객체를 마킹하고 제거하는 과정에서 성능 저하가 발생할 수 있으며, 메모리 단편화가 발생할 수 있습니다.

### Copy 알고리즘
1. 활성 영역 분리: 힙 영역을 두 개의 반으로 나눕니다. 한쪽 영역은 현재 사용되고, 다른 쪽 영역은 비어 있습니다.
2. 카피 단계: 현재 사용 중인 영역에서 사용 중인 객체를 식별하고, 이를 비어 있는 영역으로 복사합니다.
3. 스위칭 단계: 모든 활성 객체가 복사되면 두 영역의 역할을 교체합니다.
- 장점: 메모리 단편화를 방지할 수 있습니다.
- 단점: 사용 가능한 메모리 공간이 절반으로 줄어듭니다.

### Mark-Compact 알고리즘
1. 마킹 단계: 사용 중인 객체를 식별하고 마킹합니다.
2. 컴팩트 단계: 마킹된 객체를 힙의 한쪽 끝으로 이동하여 연속된 메모리 블록을 만듭니다.
- 장점: 메모리 단편화를 방지할 수 있습니다.
- 단점: 객체를 이동시키는 과정에서 성능 저하가 발생할 수 있습니다.

## Java에서의 GC
Java의 JVM은 다양한 GC 알고리즘을 지원합니다. 주로 사용되는 GC알고리즘은 다음과 같습니다.
- Serial GC: 단일 스레드를 사용하여 GC를 수행합니다. 작은 애플리케이션에 적합합니다.
  - Mark-and-Sweep 알고리즘을 사용하여 GC를 수행합니다.
  - Stop-the-World(STW) 이벤트 동안 애플리케이션 실행을 멈추고 GC를 수행합니다.
    - STW 이벤트??
      - JVM의 GC과정에서 애플리케이션의 모든 실행 스레드를 일시적으로 중단시키는 이벤트를 의미합니다.
      - GC가 메모리를 관리하는 동안 객체의 참조가 변경되지 않도록 모든 애플리케이션 스레드를 중단시킴으로써 메모리 안정성을 확보합니다.
- Parallel GC: 여러 스레드를 사용하여 GC를 병렬로 수행합니다. 다중 코어 시스템에서 성능이 향상됩니다.
  - Mark-and-Compact 알고리즘을 사용하여 GC를 수행합니다.
  - Young Generation에서는 Copying 알고리즘을 사용하여 객체를 복사합니다.
  - Old Generation에서는 Mark-and-Compact 알고리즘을 사용하여 객체를 정리합니다.
- CMS(Concurrent Mark-Sweep) GC: 애플리케이션 스레드와 동시에 GC를 수행하여 긴 정지 시간을 피합니다.응답시간이 중요한 애플리케이션에 적합합니다.
  - Mark-and-Sweep 알고리즘을 사용하여 GC를 수행합니다.
  - GC 과정은 Initial Mark, Concurrent Mark, Remark, Concurrent Sweep의 4단계로 이루어집니다.
    - Initial Mark: Stop-the-World 이벤트 동안 루트 객체를 마킹합니다.
    - Concurrent Mark: 애플리케이션 스레드와 동시에 객체 그래프를 탐색하여 사용 중인 객체를 마킹합니다.
    - Remark: Stop-the-World 이벤트 동안 변경된 객체를 다시 마킹합니다.
    - Concurrent Sweep: 마킹되지 않은 객체를 메모리에서 제거합니다.
- G1(Garbage First): 힙을 여러 영역으로 나누어, 가비지가 많은 영역을 우선적으로 정리합니다. 대규모 애플리케이션에 적합합니다.
  - Mark-and-Compact 알고리즘을 기반으로 하여 GC를 수행합니다.
  - 힙을 여러 개의 고정된 크기의 영역으로 나누고, 각 영역의 가비지 비율을 계산하여 가장 가비지가 많은 영역을 우선적으로 정리합니다.
  - Young Generation에서는 Copying 알고리즘을 사용하여 객체를 이동합니다.
  - Old Generation에서는 Mark-and-Compact 알고리즘을 사용하여 객체를 정리합니다.
  - Mixed GC 사이클을 통해 Young Generation과 Old Generation을 동시에 정리합니다.
- ZGC(Z Garbage Collector): 매우 짧은 정지 시간(약 10ms 이하)을 목표로 합니다. 대규모 힙 메모리를 가진 애플리케이셔에 적합합니다.
  - Region-based 알고리즘을 사용하여 GC를 수행합니다.
  - 컬렉션 과정은 Mark, Relocate, Reclaim의 3단계로 이루어집니다.
    - Mark: 애플리케이션 스레드와 동시에 객체 그래프를 탐색하여 사용 중인 객체를 마킹합니다.
    - Relocate: 마킹된 객체를 새로운 위치로 이동합니다.
    - Reclaim: 사용되지 않는 메모리를 회수합니다.

### Java에서 G1 GC 동작 예시
1. Initial Mark: Young Generation의 객체를 마킹하는 단계로 루트 객체를 마킹합니다. 이 과정은 Stop-the-World 이벤트 동안 수행됩니다.
2. Concurrent Mark: 애플리케이션 스레드와 동시에 객체 그래프를 탐색하여 사용 중인 객체를 마킹합니다. Old Generation의 객체를 마킹합니다.
3. Remark: Stop-the-World 이벤트 동안 변경된 객체를 다시 마킹합니다.
4. CleanUp: 마킹되지 않은 객체를 메모리에서 제거하고, 힙의 사용 가능한 메모리를 업데이트합니다.
5. Copying: Young Generation의 객체를 새로운 영역으로 복사합니다. 이 과정에서 살아있는 객체만 복사되므로 메모리 단편화가 방지됩니다.
6. MixedGC: Young Generation과 Old Generation을 동시에 정리합니다. 가비지가 많은 영역을 우선적으로 정리하여 효율서응ㄹ 높입니다.
   - Mixed GC 사이클의 장단점
     - 장점
       - 효율적인 메모리 정리: 동시에 정리하여 메모리 사용 효율을 높입니다.
       - Full GC 빈도 감소: Old Generation의 일부 영역을 정기적으로 정리하여 Full GC의 빈도를 줄입니다.
       - 성능 최적화: 긴 정지 시간을 피하고, 애플리케이션의 성능을 최적화합니다.
     - 단점
       - 복잡한 관리
       - 추가 오버해드
## 답변 예시
GC는 사용되지 않은 메모리를 자동으로 회수하여 메모리 누수를 방지하고, 프로그래머의 메모리 관리 부담을 줄이는 메모리 관리 기법입니다.
주요 GC 알고리즘으로는 Mark-and-Sweep, Copy, Mark-Compact 알고리즘이 있으며, 각 알고리즘은 메모리 관리와 성능 최적화 방법이 다릅니다.

