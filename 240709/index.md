# 데이터베이스의 인덱스
데이터베이스에서의 인덱스의 사용 이유 및 장단점이 무엇일까요?<br>
데이터베이스에서 인덱스를 사용하는 이유는 데이터 검색 속도를 높이고, 효율적인 쿼리 성능을 제공하기 위해서입니다. 인덱스는 데이터베이스 테이블의 특정 열에 대해 정렬된 구조를 제공하여 
검색 작업을 최적화합니다. 그러나 이덱스를 사용할 때는 장단점을 모두 고려해야 합니다.

## 인덱스 사용 이유
- 검색 성능 향상
  - 인덱스는 테이블의 특정 열에 대해 정렬된 구조를 제공하여, 검색 작업을 최적화합니다. 이는 데이터베이스가 전체 테이블을 스캔하지 않고도 필요한 데이터를 빠르게 찾을 수 있게 합니다.
- 정렬 및 그룹화 성능 향상
  - 인덱스는 ORDER BY와 GROUP BY 같은 쿼리의 성능을 향상시킬 수 있습니다.
- 고유성 보장
  - 인덱스를 사용하여 테이블의 특정 열에 대해 고유제약 조건을 적용할 수 있습니다.

## 인덱스의 장단점
- 장점
  - 빠른 검색 속도
    - 인덱스를 사용하면 데이터 검색 속도가 크게 향상됩니다. 이는 특히 대용량 테이블에서 매우 유용합니다.
  - 향상된 쿼리 성능
    - 인덱스를 통해 특정 열을 기준으로 정렬하거나 필터링하는 쿼리의 성능이 향상됩니다.
  - 고유성 제약
    - 인덱스를 사용하여 특정 열에 대해 고유성을 보장할 수 있습니다.
- 단점
  - 추가 저장 공간
    - 인덱스는 추가적인 저장 공간을 필요로 합니다. 테이블이 클수록 인덱스가 차지하는 공간도 증가합니다.
  - 쓰기 성능 저하
    - 인덱스는 데이터를 삽입, 수정, 삭제할 때마다 업데이트되어야 하므로, 쓰기 작업의 성능이 저하될 수 있습니다.
  - 복잡성 증가
    - 인덱스를 잘못 사용하면 오히려 성능을 저하시킬 수있습니다. 인덱스를 너무 많이 생성하면 오버헤드가 발생할 수 있습니다.
```sql
CREATE INDEX idx_employee_name ON employees (name);

SELECT * FROM employees WHERE name = 'John Doe';
```

## 답변 예시
데이터베이스에서 인덱스를 사용하는 이유는 검색 속도를 높이고, 효율적인 쿼리 성능을 제공하기 위해서입니다.
인덱스를 사용하면 데이터 검색 속도가 크게 향상되고, 정렬 및 그룹화 성능도 좋아집니다. 그러나 인덱스를 사용할 때 추가 저장 공간이 필요하고, 쓰기 작업의 성능이 저하될 수 있습니다.

## MySQL에서의 인덱스 동작 방식
### B-Tree Index
MySQL에서 가장 일반적으로 사용되는 인덱스는 B-트리 인덱스입니다. MySQL의 InnoDB 스토리지 엔진은 B+트리 구조를 사용하빈다.
- B+트리는 균형 잡힌 트리 구조로, 모든 리프 노드가 동일한 깊이를 가집니다. 리프 노드는 데이터의 실제 주소를 가리키는 포인터를 포함합니다.
- 동작 원리
  - 검색: 루트 노드에서 시작하여 각 노드의 키와 비교하면서 자식 노드로 이동합니다. 최종적으로 리프 노드에 도달하여 원하는 값을 찾습니다.
  - 삽입: 새로운 키를 삽입할 때는 적절한 위치를 찾아 삽입하고, 노드가 가득 차면 분할하여 균형을 유지합니다.
  - 삭제: 키를 삭제할 때는 리프 노드에서 제거하고, 노드가 비게 되면 병합하여 균형을 유지합니다.
### Hash Index
해시 인덱스는 MySQL의 MEMORY 스토리지 엔진에서 주로 사용됩니다. 해시 인덱스는 특정 키를 빠르게 찾을 때 유용하지만, 범위 검색에는 적합하지 않습니다.
- 해시 인덱스는 해시 테이블을 사용하여 키를 버킷으로 매핑합니다. 각 버킷은 하나 이상의 키-값 쌍을 포함합니다.
- 동작 원리
  - 검색: 키에 대한 해시 함수를 계산하여 해당 버킷을 찾고, 버킷 내에서 원하는 키를 검색합니다.
  - 삽입: 키를 삽입할 때는 해시 함수를 사용하여 버킷을 결정하고, 해당 버킷에 키-값 쌍을 추가합니다.
  - 삭제: 키를 삭제할 때는 해시 함수를 사용하여 버킷을 찾고 버킷 내에서 키를 제거합니다.
### 각각의 장단점
- B-트리 인덱스
  - 장점
    - 검색, 삽입, 삭제가 모두 O(logN) 시간 복잡도로 효율적입니다.
    - 데이터가 정렬된 상태로 유지되므로 범위 검색에 유리합니다.
  - 단점
    - 트리의 균형을 유지하기 위해 노드 분할 및 병합이 필요하므로, 삽입 및 삭제 작업의 오버헤드가 발생할 수 있습니다.
- 해시 인덱스
  - 장점
    - 검색 및 삽입이 매우 빠릅니다(평균 O(1))
    - 특정 키를 찾는 작업에 유리합니다.
  - 단점
    - 범위 검색을 지원하지 않습니다.
    - 해시 충돌이 발생할 수 있으며, 이를 해결하기 위한 추가 작업이 필요합니다.

## B+트리
B+트리는 데이터베이스 인덱스에서 가장 많이 사용되는 자료 구조 중 하나로, MySQL의 InnoDB 스토리지 엔진에서 사용됩니다. B+트리는 검색,삽입,삭제 작업을 효율적으로 
처리하기 위해 설계된 균형 잡인 트리 구조입니다. B+트리는 B-트리의 변형으로, 모든 데이터가 리프 노드에 저장되며 리프 노드가 연결 리스트 형태로 연결되어 있습니다.

### B+트리의 구조와 동작 원리
- 구조
  - 루트 노드 (Root Node): 트리의 최상위 노드로, 트리의 시작점입니다.
  - 내부 노드 (Internal Node): 루트 노드와 리프 노드 사이에 위치한 노드로, 자식 노드로의 포인터를 포함합니다.
  - 리프 노드 (Leaf Node): 트리의 최하위 노드로, 실제 데이터를 저장하고 있습니다. 모든 리프 노드는 연결 리스트 형태로 연결되어 있습니다.
  - 키 (Key): 노드에 저장된 값으로, 데이터 검색의 기준이 됩니다.
  - 포인터 (Pointer): 자식 노드나 데이터의 실제 위치를 가리킵니다.
- 동작 원리
  - 검색
    - 루트 노드에서 시작하여, 각 노드의 키와 비교하면서 적절한 자식 노드로 이동합니다.
    - 리프 노드에 도달할 때까지 이 과정을 반복합니다.
    - 리프 노드에서 원하는 데이터를 찾습니다.
  - 삽입
    - 새로운 키를 삽입할 위치를 검색 과정과 동일하게 찾아갑니다.
    - 적절한 리프 노드에 키를 삽입합니다.
    - 리프 노드가 가득 차면, 리프 노드를 분할하고 부모 노드에 새로운 키를 삽입합니다.
    - 부모 노드도 가득 차면, 분할을 반복하여 트리의 균형을 유지합니다.
  - 삭제
    - 삭제할 키를 검색 과정과 동일하게 찾아갑니다.
    - 리프 노드에서 키를 삭제합니다.
    - 리프 노드가 너무 비게 되면, 인접한 노드와 병합하거나 재분배하여 트리의 균형을 유지합니다.
- 장점
  - 검색, 삽입, 삭제가 모두 O(logN) 시간 복잡도로 효율적입니다.
  - 데이터가 정렬된 상태로 유지되므로 범위 검색에 유리합니다.
  - 리프 노드가 연결 리스트 형태로 연결되어 있어 순차 검색이 빠릅니다.
- 단점
  - 트리의 균형을 유지하기 위해 노드 분할 및 병합이 필요하므로, 삽입 및 삭제 작업의 오버헤드가 발생할 수 있습니다.
  - 추가적인 저장 공간이 필요합니다(포인터와 내부 노드 등)

## B+트리에서 데이터 삽입과 균형 유지
### 적절한 위치에 삽입
적절한 위치에 삽입한다는 것은 B+트리의 정렬된 구조를 유지하기 위해 새로운 키를 올바른 리프 노드에 삽입하는 것을 의미합니다. 
각 노드는 키가 오름차순으로 정렬되어 있어야 하며, 이를 통해 검색 속도를 최적화합니다.
- 과정
  - 삽입할 키의 값을 결정합니다.
  - 루트 노드에서 시작하여 삽입할 키의 값을 각 노드의 키들과 비교합니다.
  - 비교 결과에 따라 적절한 자식 노드로 이동하여 리프 노드에 도달합니다.
  - 리프 노드에 도달하면, 키를 정렬된 순서에 맞게 삽입합니다.

예를 들어 현재 B+트리에 10, 20, 30이 이미 삽입되어 있다고 가정하고 25를 삽입한다고 해봅시다.
```less
현재 상태:
  [20]
 /    \
[10] [20, 30]

삽입할 키: 25
루트 노드에서 시작 -> 20과 비교하여 오른쪽 자식 노드로 이동 -> 오른쪽 리프 노드에서 25를 정렬된 위치에 삽입:
  [20]
 /    \
[10] [20, 25, 30]
```
### 리프 노드가 가득 찼을 때의 동작
리프 노드가 가득 차면 노드를 분할하여 새로운 노드를 생성하고, 부모 노드에 새로운 키를 삽입하여 트리의 균형을 유지합니다.
- 과정
  - 리프 노드에 키를 삽입하여 노드가 가득 차면 분할을 수행합니다.
  - 노드를 분할하여 두 개의 노드로 나누고 중간 키를 부모 노드로 올립니다.
  - 부모 노드에 새로운 키를 삽입합니다.
  - 부모 노드도 가득 찼다면, 부모 노드도 분할하여 균형을 유지합니다.

### 트리의 균형 유지
트리의 균형을 유지하기 위해, 노드가 가득 차거나 비게 되면 분할과 병합읉 통해 트리의 균형을 조정합니다.
이는 B+트리의 높이가 균일하게 유지되도록 하여 검색, 삽입, 삭제 작업의 효율성을 보장합니다.
- 과정
  - 삽입 시: 노드가 가득 차면 분할하고, 중가 키를 부모 노드로 올립니다. 부모 노드도 가득 차면 동일한 과정을 반복합니다.
  - 삭제 시: 노드가 너무 비면 인접한 노드와 병합하거나, 인접한 노드에서 키를 재분배하여 균형을 유지합니다.

### 답변 예시
B+트리에서 적절한 위치에 삽입한다는 것은 새로운 키를 트리의 정렬된 구조를 유지하도록 올바른 리프 노드에 삽입하는 것을 의미합니다.
리프 노드가 가득 차면 분할하여 새로운 노드를 생성하고, 부모 노드에 중간 키를 삽입하여 트리의 균형을 유지합니다.
트리의 균형은 노드가 가득 차거나 비게 되면 분할과 병합을 통해 유지되며, 이를 통해 검색, 삽입, 삭제 작업의 효율성을 보장합니다.
