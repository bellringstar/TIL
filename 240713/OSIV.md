# OSIV (Open Session In View)
OSIV는 주로 JPA(Java Persistence API)나 Hibernate와 같은 ORM(Object-Relational Mapping) 프레임워크를 사용할 때 나오는 개념입니다.

## 기본 개념
1. 정의: OSIV는 웹 요청이 처리되는 동안 데이터베이스 커넥션(세션)을 열어두는 패턴입니다.
2. 목적
   - 뷰 렌더링 단계에서도 지연 로딩을 가능하게 합니다.
   - 영속성 컨텍스트를 뷰까지 유지하여 엔티티에 접근할 수 있게 합니다.
3. 동작방식
   - 웹 요청이 들어오면 필터나 인터셉터에서 영속성 컨텍스트를 생성합니다. Hibernate의 경우 Session이 열립니다.
   - 요청 처리가 끝나고 뷰가 렌더링될 때까지 영속성 컨텍스트를 유지합니다.
   - 뷰 렌더리이 끝나면 영속성 컨텍스트를 종료합니다. Hibernate의 경우 Session이 닫힙니다.

## OSIV의 장단점
- 장점
  - 지연 로딩 지원: 뷰 레이어에서 지연 로딩을 사용할 수 있어, 필요한 데이터만 로드할 수 있습니다.
  - 간단한 설정: 간단한 설정으로 영속성 컨텍스트를 뷰까지 열어둘 수 있습니다.
  - 데이터 액세스 편리성: 서비스 계층에서 모든 데이터를 미리 로드하지 않아도 되므로, 필요한 데이터만 로드할 수 있습니다.
- 단점
  - 리소스 사용: 데이터베이스 커넥션을 오래 물고 있어 리소스 사용량이 증가할 수 있습니다.
  - 성능 이슈: 뷰에서 예상치 못한 쿼리가 발생할 수 있어 성능 문제를 야기할 수 있습니다.
  - 동시성 문제: 긴 트랜잭션으로 인해 데이터베이스 동시성이 떨어질 수 있습니다.
  - 명확한 경계 부족: 서비스 계층과 뷰 계층 간의 경계가 모호해질 수 있습니다.

## 그런데 대부분의 경우 OSIV 설정을 비활성화한다.
정확히 말하면 대부분의 REST API 서버에서는 OSIV 옵션을 비활성화합니다. 그 이유는 성능과 트랜잭션 관리의 명확성 때문입니다.
REST API 서버는 일반적으로 데이터베이스와의 효율적인 상호 작용과 명확한 트랜잭션 경계를 중요시 하므로, OSIV를 비활성하여 이러한 목표를 달성하려고 합니다.
### 비활성화 이유
1. 성능 문제 방지
   - 긴 트랜잭션 시간: OSIV를 활성화하면 영속성 컨텍스트가 웹 요청이 완료될 때까지 열려 있어, 트랜잭션 시간이 길어질 수 있습니다. 이는 데이터베이스 연결을 오랜시간 점유하게 되어 성능 저하를 초래할 수 있습니다.
   - 비효율적인 데이터베이스 접근: 뷰 계층에서 지연 로딩을 통해서 데이터베이스 접근이 일어나면 예기치 않게 많은 쿼리가 실행될 수 있습니다. 이는 성능에 부정적인 영향을 미칠 수 있스빈다.
2. 명확한 트랜잭션 경계 유지
   - 비즈니스 로직과 프레젠테이션 로직 분리: REST API는 보통 서비스 계층에서 트랜잭션을 명확하게 관리하고, 프레젠테이션 로직(뷰)과 비즈니스 로직(서비스)을 분리하는 것을 선호합니다. OSIV를 사용하면 이 경계가 모호해질 수 있습니다.
   - 트랜잭션 일관성: 트랜잭션의 시작과 종료를 명확히 관리함으로써 데이터 일관성을 유지하고 오류를 방지할 수 있습니다.
3. 리소스 관리
   - 데이터베이스 연결 유지: OSIV가 활성화된 상태에서 데이터베이스 연결이 웹 요청 전체동안 유지되므로, 연결 수가 많아질 경우 데이터베이스 리소스를 과도하게 사용하게 됩니다. 이는 연결 풀이 고갈될 위험을 증가시킵니다.

### 비활성화시 대안
비활성화시 지연 로딩을 직접 사용할 수 없지만 서비스 계층 트랜잭션 내에서만 쓰면 된다.
1. DTO
   - 서비스 계층에서 필요한 데이터를 모두 로드한 후, DTO 객체에서 데이터를 담아 컨트롤러로 전달합니다. 이를 통해 뷰 계층에서 지연 로딩이 필요하지 않도록 합니다.
2. 명시적 로딩
   - 패치 조인 (Fetch Join): JPQL이나 HQL에서 'JOIN FETCH'를 사용하여 연관된 엔티티를 한 번에 로드합니다. 이를 통해 필요한 데이터를 한 번의 쿼리로 가져올 수 있습니다.
     - 엔티티 그래프 (Entity Graph): JPA 2.1부터 제공되는 엔티티 그래프를 사용하여, 특정 엔티티의 연관된 데이터를 미리 로드할 수 있습니다.

### 답변 예시
OSIV는 ORM 프레임 워크에서 웹 요청이 처리되는 동안 영속성 컨텍스트를 열어두는 설정으로 뷰 레이어에서 지연 로딩을 사용할 수 있게 합니다. 그렇지만 대부분의 api서버에서는 비활성화를 합니다.
그 이유는 성능 문제를 방지하고 명확한 트랜잭션 경계를 유지하기 위해서입니다. OSIV를 활성화하면 트랜잭션 시간이 길어지고, 데이텁이스 연결이 오랜 시간 유지되어 성능 저하를 초래할 수 있습니다.
대신, DTO나 페치 조인을 사용하여 필요한 데이터를 미리 로드하고 명시적으로 트랜잭션을 관리합니다.

## 이런 경우는 어떻게 동작할까?
OSIV 비활성화 기준 영속성 컨텍스트의 수명은 주로 @Transactional 어노테이션이 붙은 메서드에 의해 관리됩니다. 해당 메서드가 종료되면 해당 메서드의 트랜잭션 범위 내에서 생성된 영속성 컨텍스트도 종료됩니다.

이런 상황을 가정해보도록 하겠습니다. OSIV가 비활성화 된 상태로 UserService의 findUser 메서드와 StoreService의 메서드에 각각 트랜잭션이 걸려있는 경우입니다.
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public User findUser(Long userId) {
        return userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    }
}

@Service
public class StoreService {
    
    @Autowired
    private UserService userService;
    
    @Transactional
    public void performStoreOperation(Long userId) {
        User user = userService.findUser(userId);
        user.setName("newName");
    }
}
```
이 상황에서 더티체킹이 동작해 user의 변경된 이름이 db에 저장이 될까요? 기본적으로 됩니다.
- 영속성 컨텍스트 종료
  - findUser 메서드가 종료되면 해당 트랜잭션이 종료되고, 영속성 컨텍스트도 종료됩니다. 이로 인해 findUser 메서드에서 반환된 User 객체는 영속성 컨텍스트에서 분리된(detached) 상태가 됩니다.
- 더티 체킹 (Dirty Checking)
  - 더티 체킹은 영속성 컨텍스트가 관리하는 엔티티에 대해 변경 사항을 감지하고, 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영하는 기능입니다.
  - 분리된 상태(detached)의 엔티티는 더 이상 영속성 컨텍스트에 의해 관리되지 않으므로, 변경 사항이 자동으로 감지되지 않습니다.
- 하지만 스프링에서 트랜잭션 전파 속성은 기본적으로 REQUIRED가 적용됩니다. 이 속성은 현재 활성화된 트랜잭션이 있으면 해당 트랜잭션을 그대로 사용하고 없으면 새로운 트랜잭션을 생성합니다.
따라서, 외부 트랜잭션 내에서 다른 트랜잭션 메서드를 실행하면 두 트랜잭션이 논리적으로 병합되어 동일한 트랜잭션을 **공유하게 됩니다**.
- 트래잭션의 전파 속성을 간단하게 정리해보면 다음과 같습니다.
  - Propagation.REQUIRED
    - 기본 전파 속성입니다. 현재 트랜잭션이 존재하면 이를 사용하고, 존재하지 않으면 새로운 트랜잭션을 시작합니다.
  - Propagation.REQUIRES_NEW
    - 항상 새로운 트랜잭션을 시작합니다. 현재 트랜잭션이 존재하면 일시 정지하고, 새로운 트랜잭션을 시작합니다.
  - Propagation.SUPPROTS
    - 현재 트랜잭션이 존재하면 이를 사용하고, 존재하지 않으면 트랜잭션 없이 실행합니다.
  - Propagation.MANDATORY
    - 현재 트랜잭션이 반드시 존재해야 합니다. 존재하지 않으면 예외를 발생시킵니다.
  - Propagation.NOT_SUPPORTED
    - 현재 트랜잭션이 존재하면 이를 일시 저장하고, 트랜잭션 없이 실행합니다.
  - Propagation.NEVER
    - 현재 트랜잭션이 존재하지 않아야 합니다. 존재하면 예외를 발생시킵니다.
  - Propagation.NESTED
    - 현재 트랜잭션이 존재하면 중첩 트랜잭션을 시작하고, 존재하지 않으면 새로운 트랜잭션을 시작합니다. 중첩 트랜잭션은 부모 트랜잭선의 커밋이나 롤백에 영향을 받습니다.
### 안될 때 해결 방법
1. 명시적 병합 (Merge)
   - StoreService의 트랜잭션 범위 내에서 유저 객체를 변경하고, 변경사항을 위해 EntityManager의 merge메서드 혹은 UserRepository의 save 메서드를 사용할 수 있습니다.
   - save 메서드는 내부적으로 merge를 사용합니다.
     - save는 내부적으로 새로운 엔티티인지 우선 판단합니다. 이는 엔티티의 ID 설정 여부등을 확인합니다.
     - 새로운 엔티티라면 persist를 호출하여 영속성 컨텍스트에 추가하고 새로운 엔티티는 데이터베이스에 삽입됩니다.
     - 기존 엔티티인 경우 merge를 호출하여 영속성 컨텍스트에 병합합니다. 기존 엔티티는 업데이트 됩니다.
   - merge의 주의점
     - 영속성 컨텍스트의 변경
       - merge 메서드는 분리된 상태(detached)인 엔티티를 영속성 컨텍스트에 다시 연결합니다. 이 과정에서 새로운 영속성 컨텍스트의 인스턴스를 반환합니다. 따라서 merge 메서드를 호출한 후 반환된 객체를 사용해야합니다.
     - 자동 생성된 ID
       - merge는 새로운 엔티티가 삽입될 때, 자동 생성된 ID를 사용하는 엔티티에 대해 주의가 필요합니다. ID가 없는 새로운 엔티티는 영속성 컨텍스트에 새로운 엔티티로 간주되어 삽입됩니다.
     - 부분 업데이트
       - merge는 전체 엔티티를 복사하여 영속성 컨텍스트에 다시 연결하므로, 부분 업데이트 대신 전체 엔티티 업데이트를 하게 됩니다. 따라서 값이 비어있으면 Null이 들어가게 됩니다.
2. 재조회 (Re-query)