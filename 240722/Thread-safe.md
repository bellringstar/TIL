# Thread-safe의 의미와 설계방법

Thread-safe란 여러 스레드가 동시에 같은 코드나 데이터에 접근하더라도 프로그램의 실행에 문제가 없음을 의미합니다. 즉, 멀티스레드 환경에서 안전하게 동작하는 코드를 뜻합니다.

## 주요 포인트
1. 데이터 일관성 유지
2. 경쟁 상태(Race Condition) 방지
   - 경쟁 상태는 두 개 이상의 프로세스나 스레드가 공유 자원에 동시에 접근하려고 할 때 발생하는 문제입니다.
   - 결과가 스레드의 실행 순서에 의존합니다.
   - 예측할 수 없고 일관성 없는 결과를 초래할 수 있습니다.
   - 버그를 재현하기 어려워 디버깅이 힘들 수 있습니다.
3. 데드락(Deadlock) 회피
   - 데드락은 두 개 이상의 스레드가 서로 점유한 자원을 기달며 무한정 대기하는 상황을 말합니다.
   - 시스템이 멈추거나 응답하지 않게 됩니다.
   - 복잡한 시스템에서 발견하기 어려울 수 있습니다.
   - 발생 시 보통 시스템 재시작이 필요합니다.
   - 발생 조건 (Coffman 조건)
     - 상호 배제 (Mutual Exclusion): 자원은 한 번에 하나의 프로세스만 사용할 수 있습니다.
     - 점유와 대기 (Hold and Wait): 프로세스가 자원을 보유한 채로 다른 자원을 요청합니다.
     - 비선점 (No Preemption): 다른 프로세스가 사용 중인 자원을 강제로 뺴앗을 수 없습니다.
     - 순환 대기 (Circular Wait): 프로세스들이 순환적으로 서로의 자원을 기다립니다.
   - 방지 방법
     - 락 순서 정하기: 모든 스레드가 같은 순서로 락을 획득하도록 합니다.
     - 락 타임아웃 사용: 일정 시간 후 락 획득을 포기하고 재시도합니다.
     - 데드락 감지 및 복구: 주기적으로 데드락을 감지하고 해결합니다.
     - 자원 할당 그래프 사용: 자원 요청과 할당을 그래프로 모델링하여 순환 의존성을 방지합니다.

## Java에서 Thread-safe 구현하기
1. Synchronization
   - synchronized 키워드를 메서드나 블록에 사용하여 한 번에 하나의 스레드만 접근할 수 있도록 합니다.
   - 구현이 간단하지만 성능 저하가 발생할 수 있습니다.
   - 동작 원리
     - 모니터와 락
       - Java의 모든 객체는 내부적으로 모니터를 가지고 있습니다.
       - 모니터는 한 번에 하나의 스레드만 실행할 수 있는 동기화된 코드 영역을 정의합니다.
       - 모니터는 락이라는 메커니즘을 사용하여 동기화를 구현합니다.
     - 락 획득 과정
       - 스레드가 synchronized 블록이나 메소드에 진입하려고 할 때, JVM은 해당 객체의 락을 획득하려고 시도합니다.
       - 락이 사용 가능한 상태면, 스레드는 락을 획득하고 코드 블록을 실행합니다.
       - 락이 다른 스레드에 의해 이미 획득된 상태라면, 현재 스레드는 대기 상태로 진입합니다.
     - 락 해제 과정
       - synchronized 블록이나 메소드의 실행이 완료되면, JVM은 자동으로 락을 해제합니다.
       - 락이 해제되면, 대기 중인 다른 스레드들 중 하나가 락을 획득할 수 있게 됩니다.
     - 락의 재진입성(Reentrant)
       - Java 락은 재진입이 가능합니다. 즉 이미 락을 획득한 스레드는 같은 락을 요규하는 다른 synchronized 블록에 진입할 수 있습니다.
       - 이는 재귀적 알고리즘이나 복잡한 객체 계층 구조에서 유용합니다.
     - 원자성
       - synchronized 블록 내의 연산들은 원자적으로 실행됩니다. 즉 모든 연산이 완료되거나 아무것도 실행되지 않은 상태만 있을 수 있습니다.
     - 가시성
       - synchronized 키워드는 변수의 가시성도 보장합니다. 한 스레드에서 수정한 값은 다른 스레드에서 즉시 볼 수 있습니다.
     - 메모리 배리어
       - synchronized는 메모리 배리어 역할을 합니다. 이는 CPU 캐시와 메인 메모리 간의 데이터 동기화를 보장합니다.
     - 상호 배제
       - synchronized는 크리티컬 섹션에 대한 상호 배제르 제공합니다. 이는 동시에 하나의 스레드만 크리티컬 섹션에 진입할 수 있음을 의미합니다.
   - 성능 고려사항
     - 강력하지만 과도한 사용은 성능 저하를 일으킬 수 있습니다.
     - 락의 획득과 해제에는 오버헤드가 있으므로, 크리티컬 섹션을 최소화하는 것이 중요합니다.
     - 데드락 가능성: 잘못 사용하면 데드락이 발생할 수 있습니다.
     - 융통성 부족: 읽기 작업에 대해서도 배타적 락을 사용합니다.
     - 성능: 경쟁이 심한 상황에서는 성능이 저하될 수 있습니다.
2. Volatile
   - 변수를 메인 메모리에 저장하여 모든 스레드가 최신 값을 읽도록 합니다.
   - 간단한 동기화에 효과적이지만 복잡한 동기화에는 부적합할 수 있습니다.
   - 즉 Java의 변수를 '메인 메모리에 저장'하도록 지시하는 키워드입니다. 모든 읽기는 메인 메모리에서 직접 이루어지며 모든 쓰기는 즉시 메인 메모르로 플러시됩니다.
   - 우선 메인 메모리의 정확한 의미를 따져보겠습니다.
     - JVM 메모리 구조 관점
       - 메인 메모리는 실제로 JVM의 힙 메모리를 가리킵니다.
       - volatile 변수도 다른 객체들과 마찬가지로 힙 메모리에 저장됩니다.
     - Java 메모리 모델(JMM) 관점
       - JMM에서 메인 메모리는 모든 스레드가 공유하는 개념적인 메모리 공간을 의미합니다.
       - 이는 물리적인 메모리와 1:1로 대응되지 않는 추상적인 개념입니다.
     - 하드웨어 관점
       - 실제 물리적인 메인 메모리를 의미하는 것이 아닙니다.
       - CPU 캐시와 대비되는 개념으로 사용됩니다.
   - volatile의 실제 동작
     - 메모리 계층 구조
       - 현대 컴퓨터 아키텍처에서는 CPU 레지스터 -> L1 캐시 -> L2 캐시 -> L3 캐시 -> RAM의 계층 구조가 있습니다.
     - volatile의 역할
       - volatile은 변수의 값이 CPU 캐시에만 저장되지 않고, 항상 메모리 계층의 가장 낮은 레벨(보통 L3 캐시나 RAM)까지 동기화되도록 보장합니다.
     - 가시성 보장
       - 다른 CPU 코어에서 실행되는 스레드들이 항상 최신 값을 볼 수 있도록 합니다.
     - 캐시 일관성 프로토콜
       - MESI와 같은 프로토콜을 통해 다른 코어의 캐시 라인을 무효화하고 업데이트합니다.
   - 로우레벨 동장 원리
     - 메모리 가시성
       - 일반 변수는 CPU 캐시에 저장될 수 있어 다른 코어의 스레드에게 즉시 보이지 않을 수 있습니다.
       - Volatile 변수는 항상 메인 메모리에서 읽고 씁니다. 따라서 모든 스레드에게 즉시 가시적입니다.
     - 메모리 배리어
       - Volatile 읽기/쓰기 연산은 메모리 배리어를 동반합니다.
       - 이는 volatile 읽기/쓰기 전후의 다른 메모리 연산이 재배치 되는 것을 방지합니다.
     - 원자성
       - Volatile은 단일 읽기/쓰기 연산의 원자성만을 보장합니다.
       - 복합 연산(예: i++)의 원자성은 보장하지 않습니다.
     - 캐시 일관성 프로토콜
       - 멀티코어 시스템에서 volatile 변수의 변경은 캐시 일관성 프로토콜을 통해 다른 코어에 전파됩니다.
       - 이는 MESI(Modified, Exclusive, Shared, Invalid) 프로토콜과 같은 하드웨어 레벨의 메커니즘을 통해 이루어집니다.
   - 단점과 한계
     - 제한된 원자성
       - 복합 연산의 원자성을 보장하지 않습니다. 단일 읽기/쓰기 연산에 대해서만 원자성을 제공합니다.
       - 이를 해결하기 위해 Atomic 클래스나 synchronized 블록을 사용합니다.
     - 성능 오버헤드
       - 변수에 대한 접근이 일반 변수보다 느릴 수 있습니다.
       - 메인 메모리 접근과 메모리 배리어 생성으로 인한 오버헤드가 발생합니다.
       - 성능 크리티컬한 부분에서는 다른 동기화 메커니즘을 고려하거나, 사용을 최소화합니다.
     - 캐시 효율성 감소
       - CPU 캐시를 효율적으로 활용하지 못합니다.
       - 모든 읽기/쓰기가 메인 메모리에서 직접 이루어지기 때문입니다. 캐시 활용이 중요하다면 다른 동기화 메커니즘을 고려합니다.
     - 복잡한 동기화에 부적합
       - 단순한 가시성만을 제공하며, 락이나 조건 변수와 같은 기능이 없습니다.
     - 오용 가능성
3. Atomic
   - java.util.concurrent.atomic 패키지의 클래스들을 사용합니다.
   - lock-free 알고리즘을 사용하여 성능이 좋지만 복잡한 연산에는 부적합할 수 있습니다.
4. 불변 객체
   - 객체의 상태를 변경할 수 없게 만들어 Thread-safe를 보장합니다.
   - 동기화가 필요 없어 성능이 좋지만 새 객체 생성으로 인한 오버헤드가 발생할 수 있습니다.
5. ThreadLocal
   - 각 스레드에 고유한 변수를 제공합니다.
   - 스레드 간 간섭을 방지하지만 메모리 사용량이 증가할 수 있습니다.
6. Lock
   - java.util.concurrent.locks 패키지의 Lock 인터페이스를 구현한 클래스들을 사용합니다.
   - synchronized보다 세밀한 제어가 가능하지만 사용법이 복잡할 수 있습니다.
7. Concurrent
   - java.util.concurrent 패키지의 Thread-safe한 컬렉션 클래스들을 사용합니다.
   - 별도의 동기화 없이 Thread-safe한 컬렉션을 사용할 수 있습니다. 하지만 일반 컬렉션에 비해 성능이 떨어질 수 있습니다.

> Thread-safe란 여러 스레드가 동시에 같은 코드나 데이터에 접근하더라도 프로그램이 정확하게 동작하는 것을 의미합니다. 자바에서는 이를 구현하기 위해 다양한 방법을 제공합니다.
> 첫째, synchronized 키워드를 사용하여 메서드나 블록에 대한 접근을 동기화할 수 있습니다.
> 둘째, volatile 키워드를 사용하여 변수의 가시성을 보장할 수 있습니다.
> 셋째, java.util.concurrent 패키지의 Atomic 클래스들을 사용하여 원자적 연산을 수행할 수 있습니다.
> 넷째, 불변 객체를 사용하여 변경 없이 Thread-safe를 보장할 수 있습니다.
> 다섯째, ThreadLocal을 사용하여 각 스레드에 고유한 변수를 제공할 수 있습니다.
> 이러한 방법들을 상황에 맞게 적절히 조합하여 사용하면 효과적으로 Thread-safe한 코드를 작성할 수 있습니다. 예를 들어, 싱글톤 패턴을 구현할 때는 Double-checked locking과 volatile 키워드를 함께 사용하여
>  Thread-safe하면서도 성능이 최적화된 코드를 작성할 수 있습니다.