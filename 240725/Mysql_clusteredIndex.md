# Mysql의 clusteredIndex

mysql의 pk는 clustered Index로 정렬된 상태를 유지하고 있다. 그런데 pk가 숫자일때는 이해가간다. 그렇지만 문자열이거나 UUID같은게 pk가 된다면 어떤 식으로 정렬이 될까?

## Clustered Index
- 테이블의 실제 데이터를 인덱스 키의 순서대로 물리적으로 정렬하여 저장하는 방법. MySQL InnoDB 엔진에서는 기본적으로 PK가 클러스터드 인덱스가 된다.
- 테이블 당 하나만 존재할 수 있다.
- 데이터 페이지를 물리적 순서로 결정한다.
- 일반적으로 검색 성능이 좋고 특히 범위 검색에서 유리하다.


## 문자열과 UUID 특성
- 문자열이나 UUID는 숫자와 달리 연속적이지 않고 예측하기 어려운 값을 가진다. 이런 특성이 클러스터드 인덱스에 어떤 영향을 끼칠까?
  - 문자열: 각 문자를 하나씩 비교해야 한다.
    - VARCHAR 혹은 CHAR로 저장되며 VARCHAR의 경우 가변 길이로 실제 데이터 길이에 따라 저장 공간이 변한다.
  - UUID: 고유성은 보장되지만, 순서가 랜덤에 가깝다.
    - CHAR(36) 또는 BINARY(16)으로 저장. CHAR(36)의 경우는 하이픈을 포함한 문자열 형태고 BINARY(16)은 이진 형태로 저장되어 공간 효율성이 높다.
  - InnoDB는 B+Tree를 인덱스 자료구조로 사용한다.
    - 문자열이나 UUID를 키로 사용할 때, 리프 노드에 실제 데이터나 데이터에 대한 포인터가 저장된다.
    - 비리프 노드에는 키 값과 하위 노드에 대한 포인터만 저장된다.
    - 문자열: VARCHAR 타입의 경우 가변 길이로 저장되어 리프 노드의 공간 활용이 효율적일 수 있습니다.
    - UUID: 고정 길이로 인해 리프 노드의 공간 활용이 예측 가능합니다.
    - 그런데 문자열이나 UUID 모두 정수형 키보다 길이가 길다. 이로 이로 인해 각 노드에 저장할 수 있는 키의 수가 줄어들어 트리의 높이가 증가할 수 있다.
    - 또한 UUID와 같은 랜덤한 값을 사용할 경우, 삽입 시 틑리의 여러 부분을 자주 재조정해야 할 수 있다.
    - 심지어 UUID는 랜덤한 분포로 인해 범위 검색의 이점이 크게 줄어든다.
    - InnoDB의 페이지 크기(기본 16KB) 내에서 B+트리 노드가 구성된다.
      - 문자열/UUID의 랜덤한 삽입으로 인해 페이지 분할이 자주 발생할 수 있다.
      - 이는 B+트리의 구조를 자주 변경시켜 I/O 비용을 증가시킬 수 있다.
## 정렬 방식
- MySQL은 문자열을 어떻게 정렬할까?
  - 기본적으로는 ASCII 순서로 정렬한다. 하지만 다국어 유니코드는? 문자열 비교 규칙은?
    - 문자 집합과 콜레이션
      - MySQL은 문자열 정렬 시 설정된 문자 집합과 콜레이션을 사용한다.
      - 문자 집합은 인코딩 방식을, 콜레이션은 정렬 규칙을 정의한다.
    - 기본 정렬 순서
      - ASCII 문자의 경우: 일반적으로 숫자 < 대문자 < 소문자 순으로 정렬
      - 예: '1' < 'A' < 'a' < 'B' < 'b'
    - 콜레이션의 영향
      - 대소문자 구분:'_ci' (case insensitive) 콜레이션은 대소문자를 구분하지 않습니다. 예: 'utf8mb4_general_ci'에서는 'a'와 'A'가 동등하게 취급됩니다.
      - 악센트 구분:'_ai' (accent insensitive) 콜레이션은 악센트를 구분하지 않습니다.
    - UUID 정렬
      - CHAR(36)으로 저장시 16진수 문자열로 취급, BINARY(16)일 때는 바이트 시퀀스로 직접 비교된다. 당연하지만 BINARY(16) 더 효율적이다. 
      - 각 문자를 순서대로 비교하므로, 시간 순서나 생성 순서와는 무관하게 정렬
    - 그래서 유니코드 어떻게 정렬되는데?
      - 문자집학과 콜레이션에 따라 다르게 처리된다.
        - 'utf8mb4_unicode_ci': 유니코드 표준에 따른 정렬. 대소문자를 구분하지 않는다.
        - 'utf8mb4_general_ci': 빠르지만 덜 정확한 정렬. 간단한 용도에 적합
        - 'utf8mb4_bin': 바이너리 정렬. 대소문자와 악센트 구분
      - 정렬 과정
        - MySQL은 각 문자에 대해 정렬 가중치를 할당한다.
        - 이 가중치에 따라 문자열이 정렬된다.
        - 복잡한 문자의 경우 분해하여 각 구성 요서를 비교할 수 있다.
    - 정렬 시 성능 고려 사항
      - 긴 문자열: 비교 시간이 길어질 수 있으므로, 필요한 경우 프리픽스 인덱스 사용을 고려할 수 있다.
      - 복잡한 콜레이션: 일부 다국어 지원 콜레이션은 정렬시 추가적인 연산을 필요로 할 수 있다.
## 성능 고려사항
- 문자열이나 UUID를 primary key로 사용할 때 발생할 수 있는 성능 이슈는?
  - 삽입시 오버헤드가 심하다. 특히 어떤 점에서 오버헤드가 심할까?
## 대안 고려
- 문자열이나 UUID를 반드시 pk로 사용해야 할 때, 성능 개선 방법이 있을까?
  - 대리 키? UUID의 변형? 복합 키?