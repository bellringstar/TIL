# Key(기본키, 후보키, 슈퍼키 등등..)에 대해 설명해 주세요.
1. 슈퍼키
- 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합니다.
- 유일성은 만족하지만, 최소성은 만족하지 않을 수 있습니다.
2. 후보키
- 슈퍼키 중에서 최소성을 만족하는 키입니다.
- 유일성과 최소성을 모두 만족합니다.
3. 기본키
- 후보키 중에서 테이블의 대표로 선택된 키입니다.
- NULL 값을 가질 수 없으며, 테이블 당 하나만 존재합니다.
4. 외래키
- 다른 테이블의 기본키를 참조하는 칼럼입니다.
- 테이블 간의 관계를 설정하고 참조 무결성을 유지하는 데 사용됩니다.

데이터베이스에서 키는 테이블 내의 레코드를 고유하게 식별하고, 테이블 간의 관계를 정의하는 중요한 개념입니다. 주요 키 타입으로는 슈퍼키, 후보키, 기본키, 외래키가 있습니다.
키의 선택은 데이터베이스 설계에 중요한 영향을 미칩니다. 예를 들어, 기본키로는 보통 변경 가능성이 낮고 NULL이 될 수 없는 속성을 선택합니다. 또한, 복합키의 사용 여부나 인조키 도입등도 고려해야 할 사항입니다.
## 기본키는 수정이 가능한가요?
1. 기술적 가능성: 대부분의 데이터베이스 시스템에서 기본키의 수정은 기술적으로는 가능합니다. 하지만 이는 여러 가지 복합한 문제를 야기할 수 있습니다.
2. 데이터 무결성 영향
   - 유일성 위반: 수정된 값이 이미 존재하는 다른 레코드의 값과 중복될 경우, 유일성 제약 조건을 위반하게 됩니다.
   - NULL 값 문제: 기본키는 NULL 값을 허용하지 않으므로, 수정 시 이 점을 반드시 고려해야 합니다.
3. 참조 무결성 영향
   - 외래키 업데이트: 다른 테이블에서 해당 기본키를 외래키로 참조하고 있다면, 모든 참조를 함께 업데이트해야 합니다.
   - CASCADE UPDATE: 이 옵션을 사용하면 자동으로 참조를 업데이트할 수 있지만, 대량의 데이터에서는 성능 문제가 발생할 수 있습니다.
4. 성능 영향
   - 인덱스 재구성: 기본키는 보통 클러스터드 인덱스로 구성되어 있어, 수정 시 인덱스 전체를 재구성해야 할 수 있습니다.
   - 락 문제: 대규모 테이블에서 기본키 수정은 광범위한 락을 발생시켜 동시성 문제를 일으킬 수 있습니다.
5. 애플리케이션 영향
   - 코드 의존성: 애플리케이션 로직이 특정 기본키 값에 의존하고 있다면, 기본키 수정 시 관련 코드도 모두 수정해야 합니다.
   - 캐시 무효화: 기본키를 기반으로 한 캐시가 있다면, 이를 모두 무효화하고 재구성해야 합니다.
6. 대안적 접근
   - 불변 기본키 사용: 자동 증가하는 정수나 UUID등 변경 가능성이 없는 값을 기본키로 사용합니다.
   - 비즈니스 키 분리: 변경 가능성이 있는 비즈니스 값은 별도의 유니크 컬럼으로 분리합니다.

기본키는 기술적으로 수정이 가능하지만, 실무에서는 매우 신중하게 접근해야 합니다. 
기본키 수정은 데이터 무결성, 참조 무결성, 성능, 그리고 애플리케이션 로직에 광범위한 영향을 미칠 수 있기 때문입니다.

특히 다른 테이블에서 외래키로 참조하고 있는 경우, 모든 참조를 함께 업데이트해야 하며 이는 큰 성능 저하를 일으킬 수 있습니다. 
또한, 기본키는 보통 클러스터드 인덱스로 구성되어 있어 수정 시 인덱스 재구성이 필요합니다.

따라서 실무에서는 변경 가능서이 있는 비즈니스 값은 별도의 컬럼으로 분리하고, 기본키로는 자동 증가하는 정수나 UUID 같은 변경될 가능성이 없는 값을 사용하는 것이 좋습니다.
만약 기본키 수정이 불가피하다면, 트랜잭션 내에서 신중하게 처리하고 모든 영향을 고려해야 합니다.

## 사실 MySQL의 경우, 기본키를 설정정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
1. MySQL의 유연성: MySQL은 테이블 생성 시 기본키 설정을 강제하지 않습니다. 이는 사용자에게 더 많은 유연성을 제공하기 위한 설계 결정입니다.
2. 내부 로우 식별자: MySQL은 내부적으로 각 로우를 식별하기 위한 메커니즘을 가지고 있습니다. 이는 사용자에게 보이지 않는 내부 식별자로, 데이터베이스 엔진이 데이터를 관리하는 데 사용됩니다.
3. AUTO_INCREMENT 컬럼: 많은 경우, 개발자들은 AUTO_INCREMENT 속성을 가진 정수 컬럼을 생성하여 이를 기본키로 사용합니다. 이 컬럼은 명시적으로 기본키로 선언되지 않아도 유일성을 보장합니다.
4. 성능과 저장 공간: 기본키가 없는 테이블은 클러스터드 인덱스를 생성하지 않으므로, 일부 상황에서는 저장 공간과 삽입 성능에 이점을 줄 수 있습니다.
5. 제약사항: 하지만 기본키 없이 테이블을 생성하는 것은 데이터 무결성과 관계형 모델의 원칙에 어긋나므로, 실제 운영 환경에서는 권장되지 않습니다.

MySQL에서는 기본키를 설정하지 않고도 테이블을 생성할 수 있습니다. 이는 MySQL의 유연한 설계 철학 때문입니다. MySQL은 내부적으로 각 로우를 식별할 수 있는 메커니즘을 가지고 있어, 명시적인 기본키 없이도 데이터를 관리할 수 있습니다.

많은 개발자들은 AUTO_INCREMENT 속성을 가진 정수 컬럼을 생성하여 이를 암묵적인 기본키로 사용합니다.
이 방식은 유일성을 보장하면서도 명시적인 기본키 선언 없이 테이블을 생성할 수 있게 합니다.

그러나 기본키 없이 테이블을 생성하는 것은 데이터 무결성과 관계형 모델의 원칙에 어긋나므로, 실제 운영 환경에서는 권장되지 않습니다.
데이터의 일관성과 무결성을 유지하기 위해서는 적절한 기본키를 설정하는 것이 좋습니다.
## 외래키 값은 NULL이 들어올 수 있나요?
1. 기본 규칙: 외래키는 기본적으로 NULL 값을 허용합니다. 이는 관계형 데이터베이스의 설계 원칙 중 하나입니다.
2. NULL의 의미: 외래키에서 NULL은 '관계 없음' 또는 '알 수 없음'을 의미합니다. 이는 선택적 관계를 표현할 때 유용합니다.
3. 제약조건: NOT NULL 제약 조건을 명시적으로 추가하지 않는 한, 외래키는 NULL을 허용합니다.
4. 참조 무결성: NULL 값은 참조 무결성 제약 조건을 위반하지 않습니다. 즉, 부모 테이블에 대응하는 값이 없어도 됩니다.
5. 주의사항: NULL을 허용하는 외래키는 조인 연산 시 주의가 필요합니다. OUTER JOIN을 사용해야 할 수 있습니다.

외래키 값으로 NULL이 허용될 수 있습니다. 이는 관계형 데이터베이스의 기본 설계 원칙 중 하나입니다.

외래키에서 NULL은 '관계 없음' 또는 '알 수 없음'을 의미합니다. 이는 선택적 관계를 표현할 때 매우 유용합니다.
예를 들어, 직원 테이블에서 모든 직원이 반드시 부서를 가질 필요가 없는 경우, 부서를 참조하는 외래키에 NULL을 허용할 수 있습니다.

외래키에 NULL을 허용하지 않으려면, 명시적으로 NOT NULL 제약조건을 추가해야 합니다. NULL 값은 참조 무결성 제약 조건을 위반하지 않기 때문에, 부모 테이블에 대응하는 값이 없어도 됩니다.

다만, NULL을 허용하는 외래키를 사용할 때는 조인 연산 시 주의가 필요합니다. NULL 값을 포함한 모든 행을 가져오려면 OUTER JOIN을 사용해야 할 수 있습니다.
## 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
1. 인덱스 생성: UNIQUE 제약 조건을 정의하면 데이터베이스 시스템은 자동으로 해당 칼럼에 대한 유니크 인덱스를 생성합니다.
2. 검색 성능 향상: 유니크 인덱스는 B-tree 구조로 구현되어 있어, 해당 칼럼을 기준으로 하는 검색 작업의 성능을 크게 향상시킵니다.
3. 중복 검사: 데이터 삽입 또는 수정 시 중복 값 검사하 필요하므로, 이 과정에서 약간의 오버헤드가 발생할 수 있습니다.
4. 조인 연산: UNIQUE 칼럼을 기준으로 하는 조인 연산의 성능이 향상될 수 있습니다.
5. 정렬 연산: UNIQUE 칼럼을 기준으로 하는 ORDER BY 절의 성능이 개선될 수 있습니다.
6. 공간 사용: 인덱스로 인해 추가정인 저장 공간이 필요합니다.

UNIQUE 키워드가 칼럼에 붙으면 해당 칼럼의 쿼리 성능에 상당한 영향을 미칩니다. 
가장 중요한 점은 데이터베이스 시스템이 자동으로 해당 칼럼에 대한 유니크 인덱스를 생성한다는 것입니다.

이 유니크 인덱스로 인해 해당 칼럼을 기준으로 하는 검색 작업의 성능이 크게 향상됩니다. 
예를 들어 WHERE 절에서 이 칼럼을 사용하는 쿼리는 매우 빠르게 실행될 수 있습니다. 또한, 이 칼럼을 기준으로 하는 조인 연산이나 ORDER BY 절의 성능도 개선될 수 있습니다.

반면, 데이터 삽입이나 수정 시에는 중복 값 검사가 필요하므로 약간의 성능 저하가 있을 수 있습니다. 또한 인덱스로 인해 추가적인 저장 공간이 필요하게 됩니다.

따라서 UNIQUE 제약 조건은 데이터의 무결성을 보장하면서도 검색 성능을 향상시키는 중요한 도구입니다. 하지만 삽입/수정 성능과 저장 공간 사용에 대한 트레이드오프를 고려해야하 합니다.