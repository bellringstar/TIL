# 프로세스가 무엇인가요?
프로세스는 실행 중인 프로그램이다. 프로세스는 프로그램 카운터로 표시되는 다음 명령어와 연관된 레지스터들의 집합, 프로세스 스택(임시 데이터를 담음), 데이터 섹션(전역 변수를 담음)을 포함하는 메모리 영역으로 구성된다.

프로세스는 실행 중인 프로그램의 인스턴스입니다. 단순히 코드 그 자체가 아니라, 실행 중인 프로그램의 현재 활동을 나타냅니다. 프로세스는 다음과 같은 요소들로 구성됩니다.
1. 프로그램 카운터: 다음에 실행할 명령어의 주소
2. 레지스터 집합: 현재 프로세스의 상태 정보
3. 프로세스 스택: 함수 호풀, 지역 변수 등 임시 데이터
4. 데이터 섹션: 전역 변수 저장
5. 힙: 동적으로 할당된 메모리
이러한 구성 요소들이 프로세스의 '컨텍스트'를 형성하며, 운여에제는 이를 관리하여 여러 프로세스 간의 전환을 가능하게 합니다.
## 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
1. 프로그램
   - 정의: 디스크와 같은 저장 장치에 저장된 실행 가능한 파일입니다.
   - 특징: 수동적인 엔티티로, 실행되기 전까지는 단순히 명령어와 데이터의 집합입니다.
   - 예: 컴퓨터에 설치된 워드 프로세서 애플리케이션 파일
2. 프로세스
   - 정의: 실행 중인 프로그램의 인스턴스입니다.
   - 특징:
     - 독립적인 메모리 공간 (코드, 데이터, 스택, 힙)을 가집니다.
     - PCB(Process Control Block)를 통해 운영체제에 의해 관리됩니다.
     - 다른 프로세스와 자원을 공유하지 않습니다. (IPC를 통한 명시적 통신 제외)
   - 예: 워드 프로세서를 실행하여 문서를 편집하는 중인 상태
3. 스레드
   - 정의: 프로세스 내에서 실행되는 더 작은 실행 단위입니다.
   - 특징:
     - 같은 프로세스 내의 다른 스레드와 코드, 데이터, 힙 영역을 공유합니다.
     - 각 스레드는 고유한 스택과 레지스터 집합을 가집니다.
     - 컨텍스트 스위칭이 프로세스보다 빠릅니다.
   - 예: 워드 프로세서에서 문서 편집, 맞춤법 검사, 자동 저장을 동시에 수행하는 각각의 작업

프로세스 vs 스레드
- 자원 공유: 프로세스는 독립적, 스레드는 자원 공유
- 생성 비용: 프로레스 새성이 더 비쌈
- 컨텍스트 스위칭: 스레드 간 전화이 더 빠름
- 안정성: 한 프로세스의 문제가 다른 프로세스에 영향을 주지 않음, 반면 한 스레드의 문제가 같은 프로세스의 다른 스레드에 영향을 줄 수 있음

프로그램, 프로세스, 스레드는 서로 연관되어 있지만 다른 개념입니다.

프로그램은 컴퓨터에 저장된 실행 가능한 파일입니다. 예를 들면,제가 사용하는 IDE나 워드 프로세서 같은 것들이 프로그램이라고 할 수 있습니다.

프로세스는 이 프로그램이 실행되어 메모리에 로드된 상태를 말합니다. 프로세스는 자신만의 메모리 공간을 가지고 있어 다른 프로세스와 독립적으로 실행됩니다. 예를 들어, 제가 워드 프로세서로 문서를 작성하고 있다면 그게 하나의 프로세스라고 볼 수 있습니다.

스레드는 프로세스 내에서 실행되는 더 작은 실행 단위입니다. 같은 프로세스 내의 스레드들은 메모리와 자원을 공유하면서 병렬적으로 작업을 수행할 수 있습니다. 아까의 워드 프로세서 예시로 보면, 문서 편집, 맞춤법 검사, 자동 저장 같은 기능들이 각각 다른 스레드에서 실행될 수 있습니다.
## PCB가 무엇인가요?
PCB(Process Control Block)는 운영체제에서 프로세스를 관리하기 위해 사용하는 데이터 구조입니다.
각 프로세스마다 하나의 PCB가 할당되며, 프로세스의 상태 정보를 저장합니다. PCB는 다음과 같은 정보를 포함합니다.
1. 프로세스 식별자(Process ID): 각 프로세스 고유 ID
2. 프로세스 상태: new, ready, running, waiting, terminated 등
3. 프로그램 카운터: 다음에 실행할 명령어 주소
4. CPU 레지스터: 누산기, 인덱스 레지스터, 스택 포인터 등
5. CPU 스케쥴링 정보: 우선순위, 스케쥴링 큐 포인터 등
6. 메모리 관리 정보: 베이스와 리미트 레지스터, 페이지 테이블, 세그머늩 테이블 등
7. 계정 정보: CPU 사용 시간, 실제 사용 시간, 시간 제한 등
8. I/O 상태 정보: 프로세스에 할당된 I/O 장치 목록, 열린 파일 목록등
PCB는 운영체제가 프로세스 간 컨텍스트 스위칭을 수행할 때 중요한 역할을 합니다. 현재 실행 중인 프로세스의 상태를 PCB에 저장하고, 다음 실행할 프로세스의 PCB 정보를 불러와 실행 컨텍스트를 복원합니다.

PCB 즉 Process Control Block은 운영체제에서 프로세스를 관리하기 위한 핵심적인 데이터 구조입니다. 각 프로세스마다 하나의 PCB가 할당되며, 이는 프로세스의 현재 상태와 관련된 모든 중요 정보를 포함합니다.

PCB에는 프로세스 ID, 현재 프로세스 상태, 프로그램 카운터, CPU 레지스터 값, CPU 스케줄링 정보, 메모리 관리 정보 등이 저장됩니다. 이 정보들은 프로세스의 실행 컨텍스트를 구성하며, 운영체제가 프로세스 간 전환을 수행할 때 사용됩니다.

특히, PCB는 컨텍스트 스위칭 과정에서 중요한 역할을 합니다. 예를 들어, 프로세스 A에서 프로세스 B로 전환할 때, 운영체제는 프로세스 A의 현재 상태를 PCB에 저장하고, 프로세스 B의 PCB에서 정보를 읽어와 실행 컨텍스트를 복원합니다.

## 그렇다면 스레드는 PCB를 갖고 있을까요?
스레드와 PCB의 관계는 운영체제의 구현에 따라 라를 수 있지만 일반적으로 다음과 같은 개념으로 이해할 수 있습니다.
1. Thread Control Block(TCB)
   - 스레드는 일반적으로 PCB 대신 TCB를 가집니다.
   - TCB는 PCB와 유사하지만, 스레드 특정 정보만을 포함합니다.
   - TCB에는 스레드 ID, 스택 포인터, 프로그램 카운터, 레지스터 상태, 스레드 상태 등이 포함됩니다.
2. PCB와 TCB의 관계
   - 하나의 프로세스에 속한 모든 스레드는 같은 PCB를 공유합니다.
   - 각 스레드는 자신만의 TCB를 가집니다.
   - PCB는 프로세스 전체에 관한 정보(메모리 관리 정보, 열린 파일 목록 등)을 포함하고, TCB는 개별 스레드에 특정한 정보를 포함합니다.
3. 구현의 차이
   - 일부 분영체제에서는 PCB 내에 TCB 정보를 포함시키기도 합니다.
   - 리눅스의 경우, 'task_struct'라는 구조체를 사용하여 프로세스와 스레드를 모두 표현합니다. 이는 프로세스와 스레드를 동이랗ㄴ 방식으로 다루는 리눅스의 특성 때문입니다.
4. 자원의 공유
   - 같은 프로세스 내의 스레드들은 PCB에 저장된 많은 정보(메모리 공간, 열린 파일 등)를 공유합니다.
   - 각 스레드의 TCB에는 스레드 고유의 정보만 저장됩니다.

스레드는 정확히 말해 PCB를 갖고 있지 않습니다. 대신, 스레드는 일반적으로 TCB(Thread Control Block)라고 불리는 유사한 구조를 가집니다.

PCB가 프로세스의 전체적인 정보를 저장하는 반면, TCB는 개별 스레드에 특정한 정보만을 저장합니다. 예를 들어, TCB에는 스레드 ID, 스택 포인터, 프로그램 카운터, 레지스터 상태 등이 포함됩니다.

중ㅇ한 점은 같은 프로세스 내의 모든 스레드가 하나의 PCB를 공유한다는 것입니다. 이는 스레드들이 프로세스의 메모리 공간, 열린 파일 목록 등의 자원을 공유하기 때문입니다. 각 스레드는 이 공유된 PCB 정보와 함께 자신만의 TCB를 가집니다.

운영체제에 따라 구현 방식이 다를 수 있는데, 예를 들어 리눅스의 경우 'task_struct'라는 단일 구조체를 사용하여 프로세스와 스레드를 모두 표현합니다. 이는 리눅스가 프로세스와 스레드를 매우 유사하게 취급하기 때문입니다.

결론적으로 스레드는 PCB를 직접 갖지는 않지만, TCB를 통해 관리되며 동시에 자신이 속한 프로세스의 PCB 정보를 공유합니다. 이러한 구존느 스레드가 가볍고 효율적으로 동작하면서도 프로세스의 자원을 공유할 수 있게 해줍니다.
## 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
리눅스에서 프로세스와 스레드의 생성은 매우 유사한 메커니즘을 사용합니다. 이는 리눅스가 프로세스와 스레드를 거의 동일하게 취급하기 때문입니다.
1. 프로세스 생성
   - 리눅스에서 새 프로세스는 fork() 시스템 콜을 통해 생성됩니다.
   - fork()는 현재 프로세스의 거의 완벽한 복사본을 생성합니다.
   - 자식 프로세스는 부모 프로세스와 동일한 코드, 데이터, 힙, 스택을 가집니다.
   - Copy-on-Write (CoW) 기법을 사용하여 효율성을 높입니다.
   - 보통 fork() 후에 exec() 계열 함수를 호출하여 새로운 프로그램을 로드합니다.
2. 스레드 생성
   - 리눅스에서 스레드는 clone() 시스템 콜을 사용하여 생성됩니다.
   - clone()은 fork()의 일반화된 버전으로, 더 많은 유연성을 제공합니다.
   - CLONE_VM, CLONE_FS, CLONE_FILES, CLONE_SIGHAND 등의 플래그를 사용하여 자원 공유를 제어할 수 있습니다.
   - 대부분의 경우, 사용자 공간 라이브러리(예: pthreads)가 clone() 호출을 추상화합니다.
3. task_struct
   - 리눅스 커널에서 프로세스와 스레드는 모두 task_struct로 표현됩니다.
   - task_struct는 스케줄링 단위인 '태스크'를 나타냅니다.
   - 프로세스와 스레드의 주요 차이점은 자원 공유의 정도입니다.
4. 경량 프로세스 (LWP)
   - 리눅스에서 스레드는 때떄로 '경량 프로세스'라고도 불립니다.
   - 이는 스레드가 프로세스와 매우 유사하게 구현되었음을 반영합니다.

리눅스에서 프로세스와 스레드의 생성은 매우 유사한 메커니즘을 사용합니다. 이는 리눅스가 프로세스와 스레드를 거의 동일한 개념으로 취급하기 때문입니다.

프로세스 생성의 경우, fork() 시스템 콜을 사용합니다. fork()는 현재 실행 중인 프로세스의 거의 완벽한 복사본을 생성합니다. 
이때 Copy-on-Write 기법을 사용하여 메모리 사용의 효율성을 높입니다. 보통 fork() 후에는 exec() 계열 함수를 호출하여 새로운 프로그램을 로드합니다.

스레드 생성의 경우, clone() 시스템 콜을 사용합니다. clone()은 fork()의 일반화된 버전으로, 더 많은 유연성을 제공합니다. 
다양한 플래그를 사용하여 자원 공유의 정도를 제어할 수 있습니다. 예를 들어, CLONE_VM 플래그를 사용하면 메모리를 공유하는 스레드를 생성할 수 있습니다.

리눅스 커널 내부에서는 프로세스와 스레드 모두 task_struct라는 동일한 구조체로 표현됩니다. 이 task_struct는 스케줄링의 기본 단위인 '태스크'를 나타냅니다. 프로세스와 스레드의 주요 차이점은 자원 공유의 정도에 있습니다.

실제 개발에서는 대부분 저수준의 시스템 콜을 직접 사용하지 않고, pthreads와 같은 고수준 라이브러리를 통해 스레드를 생성합니다. 이러한 라이브러리들은 내부적으로 clone() 시스템 콜을 사용하여 스레드를 생성합니다.
## 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 묵게 되면 어떻게 처리하나요?
자식 프로세스가 상태를 알리지 않고 죽거나 부모 프로세스가 먼저 죽는 상황은 운영체제에서 중요한 문제입니다. 이를 처리하기 위해 다음과 같은 메커니즘이 사용됩니다.
1. 좀비 프로세스
   - 자식 프로세스가 종료되었지만, 부모 프로세스가 자식의 종료 상태를 회수하지 않은 상태를 말합니다.
   - 좀비 프로세스는 시스템 자원을 거의 사용하지 않지만, 프로세스 테이블 공간을 차지합니다.
   - wait(), waitpid() 시스템 콜을 통해 부모 프로세스가 자식 프로세스의 종료 상태를 회수할 수 있습니다.
2. 고아 프로세스
   - 부모 프로세스가 자식 프로세스보다 먼저 종료된 경우, 자식 프로세스를 고아 프로세스라고 합니다.
   - 리눅스에서는 init 프로세스(PID 1)가 모든 고아 프로세스의 새로운 부모가 됩니다.
   - init 프로세스는 주기적으로 wait() 시스템 콜을 호출하여 고아 프로세스들의 종료 상태를 회수합니다.
3. 시그널 처리
   - SIGCHLD 시그널: 자식 프로세스가 종료, 중지, 또는 재개될 때 부모 프로세스에게 전송됩니다.
   - 부모 프로세스는 SIGCHLD 시그널 핸들러를 설정하여 자식 프로세스의 상태 변화에 대응할 수 있습니다.
4. 자원 회수
   - 프로세스가 종료되면 대부분의 자원(메모리, 파일 디스크립터 등)은 운영체제에 의해 자동으로 회수됩니다.
   - 그러나 프로세스의 종료 상태와 일부 정보는 부모 프로세스가 확인할 때까지 유지됩니다.
5. 좀비 프로세스 방지
   - double fork 기법: 데몬 프로세스를 생성할 때 사용되며, 두 번의 fork()를 통해 부모 프로세스와의 연결을 끊습니다.
   - SIGCHLD 시그널을 SIG_IGN으로 설정: 자식 프로세스의 종료를 무시하고 자동으로 좀비 상태를 방지합니다.

리눅스에서는 자식 프로세스가 상태를 알리지 않고 죽거나 부모 프로세스가 먼저 죽는 상황을 효과적으로 처리하기 위한 여러 메커니즘이 있습니다.

자식 프로세스가 종료되었지만 부모 프로세스가 그 상태를 확인하지 않는 경우, 해당 자식 프로세스는 '좀비 프로세스'가 됩니다. 
좀비 프로세스는 시스템 자원을 거의 사용하지 않지만, 프로세스 테이블의 항목을 차지합니다. 
부모 프로세스는 wait() 또는 waitpid() 시스템 콜을 사용하여 자식 프로세스의 종료 상태를 확인하고 좀비 상태를 해제할 수 있습니다.

반대로, 부모 프로세스가 자식 프로세스보다 먼저 종료되면 자식 프로세스는 '고아 프로세스'가 됩니다. 
리눅스에서는 init 프로세스(PID 1)가 모든 고아 프로세스의 새로운 무보가 되어 이들의 종료 상태를 주기적으로 확인합니다.

또한, 리눅스는 SIGCHLD 시그널을 통해 부모 프로세스에게 자식 프로세스의 상태 변화를 알립니다. 
부모 프로세스는 이 시그널을 처리하는 핸들러를 설정하여 자식 프로세스의 종료에 즉시 대응할 수 있습니다.

실제 개발 시에는 좀비 프로세스를 방지하기 위해 SIGCHILD 시그널을 SIG_IGN으로 설정하거나, 데몬 프로세스 생성 시 double fork 기법을 사용하는 등의 방법을 활용할 수 있습니다.

### SIG_IGN
SIG_IGN은 POSIX 표준에 정의된 특별한 시그널 핸들러 값입니다. 이는 'Signal Ignore'의 약자로, 시그널을 무시하도록 지정하는 데 사용됩니다.
1. 정의
   - <signal.h> 헤더 파일에 정의되어 있습니다.
   - 실제로는 함수 포인터 타입의 상수입니다.
2. 사용
   - signal() 또는 sigaction() 함수를 통해 시그널 핸들러로 설정됩니다.
   - 예: signal(SIGCHLD, SIG_IGN);
3. 효과
   - 해당 시그널이 프로세스에 전달되면 아무 동작도 하지 않고 무시됩니다.
   - 일부 시그널(SIGKILL, SIGSTOP)은 무시할 수 없습니다.
4. SIGCHLD와의 특별한 관계
   - SIGCHLD를 SIG_IGN으로 설정하면, 자식프로세스가 종료될 때 자동으로 회수되어 좀비 프로세스가 생성되지 않습니다.
5. 주의사항
   - 중요한 시그널을 무시하면 프로그램의 정상적인 동작에 영향을 줄 수 있습니다.
   - 몯느 시그널에 대해 무분별하게 사용하는 것은 권장되지 않습니다.

SIG_IGN은 POSIX 표준에 정의된 특별한 시그널 핸들러 값입니다. 'Signal Ignore'의 약자로, 특정 시그널을 무시하도록 지정할 때 사용됩니다.

프로그래밍에서 SIG_IGN은 주로 signal() 또는 sigaction() 함수를 통해 시그널 핸들러로 설정됩니다. 예를 들어, 'signal(SIGCHLD, SIG_IGN);'와 같이 사용하면 SIGCHLD 시그널을 무시하도록 설정할 수 있습니다.

SIG_IGN의 주요 특징은 해당 시그널이 프로세스에 전달되었을 때 아무런 동작도 하지 않고 단순히 무시한다는 것입니다. 하지만 SIGKILL이나 SIGSTOP과 같은 일부 시그널은 무시할 수 없습니다.

특히 SIGCHLD 시그널을 SIG_IGN으로 설정하면 흥미로운 부작용이 있습니다. 이 경우 자식 프로세스가 종료될 때 자동으로 회수되어 좀비 프로세스가 생성되지 않습니다. 이는 좀비 프로세스 방지를 위한 간단한 방법 중 하나로 사용됩니다.
하지만 SIG_IGN을 사용할 때는 주의가 필요합니다. 중요한 시그널을 무시하면 프로그램의 정상적인 동작에 영향을 줄 수 있으므로, 각 시그널의 의미와 영향을 잘 이해하고 사용해야 합니다."
### double fork
Double fork 기법(또는 'daemonize' 기법)은 데몬 프로세스를 생성할 때 사용되는 방법으로, 두 번의 연속적인 fork() 호출을 통해 프로세스를 완전히 독립시키는 기법입니다.

과정
1. 부모 프로세스가 첫 번째 fork()를 호출하여 자식 프로세스를 생성합니다.
2. 부모 프로세스는 즉시 종료됩니다.
3. 자식 프로세스가 두 번째 fork()를 호출하여 손자 프로세스를 생성합니다.
4. 자식 프로세스도 즉시 종료됩니다.
5. 소자 프로세스가 최종적인 데몬 프로세스가 됩니다.

좀비 프로세스 방지 원리
1. 첫 번째 fork() 후 부모가 즉시 종룧되면, 자식 프로세스는 init 프로세스(PID 1)의 자식이 됩니다.
2. 두 번째 fork() 후 자식이 종료되면, 손자 프로세스도 init 프로세스의 자식이 됩니다.
3. init 프로세스는 자동으로 자식 프로세스들의 종료 상태를 수집하므로, 좀비 프로세스가 생성되지 않습니다.

추가 이점
1. 세션 리더 방지: 두 번째 fork()로 생성된 프로세스는 세션 리더가 될 수 없어, 제어 터미널 할당을 완전히 방지할 수 있습니다.
2. 완전한 분리: 원래의 부모 프로세스로부터 완전히 독립된 프로세스를 만들 수 있습니다.
## 리눅스에서 데몬프로세스에 대해 설명해 주세요.
데몬 프로세스는 리눅스와 유닉스 계열 운영체제에서 중요한 개념입니다. 다음은 데몬 프로세스의 주요 특징과 생성 방법입니다.
1. 정의
   - 데몬은 백그라운드에서 실행되는 장기 실행 프로세스 입니다.
   - 보통 시스템 서비스를 제공하며, 사용자 사옿작용 없이 동작합니다.
2. 특징
   - 제어 터미널이 없습니다.
   - 대부분 root 권한으로 실행됩니다.
   - 보통 시스템 부팅 시 시작되어 시스템 종료 시까지 실행됩니다.
   - 이름이 대게 'd'로 끝납니다 (예: sshd, httpd)
3. 생성 과정
   - fork()를 호출하여 자식 프로세스 생성
   - 부모 프로세스 종료
   - setsid()를 호출하여 새로운 세션 생성
   - 작업 디렉토리를 '/'로 변경
   - 표준 입출력과 에러 스트림을 /dev/null로 리다이렉트
   - 필요한 경우 두 번째 fork()
4. 더블 포킹
   - 세션 리더가 되는 것을 방지하고, 완전히 제어 터미널과의 연결을 끊기 위해 사용됩니다.
   - 좀비 프로세스 생성을 방지합니다.
5. 로킹
   - 데몬은 보통 syslog를 통해 로그를 남깁니다.
   - 직접적인 콘솔 출력은 피해야 합니다.
6. 시그널 처리
   - 데몬은 적절한 시그널 핸들러를 설정하여 종료나 재시작 등의 동작을 처리합니다.
7. PID 파일
   - 많은 데몬들이 /var/run 디렉토리에 자신의 PID를 기록한 파일을 생성합니다.
   - 이는 다른 프로세스가 데모을 쉽게 찾고 통신할 수 있게 합니다.

리눅스에서 데몬 프로세스는 백그라운드에서 지속적으로 실행되는 특별한 유형의 프로세스입니다. 주로 시스템 서비스를 제공하며, 사용자 상호작용 없이 동작합니다.

데몬 프로세스의 주요 특징으론느 제어 터미널이 없다는 점, 대부분 root 권한으로 실행된다는 점, 그리고 보통 시스템 부팅 시 시작되어 시스템이 종료될 때까지 실행된다는 점이 있습니다. 
데몬 프로세서의 이름은 대게 'd'로 끝나는데, 예를들면 sshd나 httpd가 있습니다.

데몬 프로세스를 생성하는 표준적인 방법은 다음과 같습니다.
1. fork()를 호출하여 자식 프로세스를 생성합니다.
2. 부모 프로세스를 종료합니다.
3. setsid()를 호출하여 새로운 세션을 생성합니다.
4. 작업 디렉토리를 루트('/')로 변경합니다.
5. 표준 입출력과 에러 스트림을 /dex/null로 리다이렉트합니다.
6. 필요한 경우 두 번째 fork()를 호출합니다 (더블 포킹)

더블 포킹 기법은 세션 리더가 되는 것을 방지하고, 완전히 제어 터미널과의 연결을 끊기 위해 사용됩니다. 
또한 이는 좀비 프로세스 생성을 방지하는 데에도 도움이 됩니다.

데몬 프로세스는 보통 syslog를 통해 로그를 남기며 적절한 시그널 핸들러를 설정하여 종료나 재시작 등의 동작을 처리합니다. 또한, 많은 데몬들이 /var/run 디렉토리에 자신의 PID를 기록한 파일을 생성하여 다른 프로세스가 쉽게 찾고 통신할 수 있게 합니다.
## 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.ㅌ
리눅스 프로세스 트리의 루트 노드에 위치하는 프로세스는 'init'프로세스라고 불립니다. 
최근 대부분의 리눅스 배포한에서는 이 역할을 'systemd'가 수행합니다. 이 프로세스의 주요 특징은 다음과 같습니다.
1. PID 1
   - init 프로세스는 항상 프로세스 ID (PID) 1을 가집니다.
   - 커널이 부팅 과정에서 직접 생성하는 첫 번째 사용자 공간 프로세스입니다.
2. 프로세스 트리의 루트
   - 모든 다른 프로세스는 init의 자식 또는 자손 프로세스입니다.
   - 고아 프로세스(부모가 종료된 프로세스)의 새로운 부모가 됩니다.
3. 시스템 초기화
   - 시스템 부팅 과정에서 다른 프로세스들을 시작합니다.
   - 시스템 설정 파일을 읽고 시스템을 적절한 실행 레벨로 가져갑니다.
4. 좀비 프로세스 정리
   - 주기적으로 wait() 시스템 콜을 호출하여 종료된 자식 프로세스의 상태를 수집합니다.
   - 이를 통해 좀비 프로세스가 시스템 자원을 계속 차지하는 것을 방지합니다.
5. 종료 불가능
   - init 프로세스는 SIGKILL을 포함한 대부분의 시그널에 의해 종료되지 않습니다.
   - 시스템의 안정성을 위해 항상 실행 중이어야 합니다.
6. systemd
   - 현대 리눅스 시스템에서는 systemd가 전통적인 init의 역할을 대체했습니다.
   - 병렬 처리를 통한 부팅 속도 향상, 의존성 관리, 서비스 관리 등 추가 기능을 제공합니다.
7. 서비스 관리
   - 시스템 서비스의 시작, 중지, 재시작을 관리합니다.
   - 서비스 간의 의존성을 관리합니다.

리눅스 프로세스 트리의 루트 노드에 위치하는 프로세스는 전통적으로 'init' 프로세스라고 불립니다. 
최근 대부분의 리눅스 배포판에서는 이 역할을 systemd가 수행하고 있습니다.

이 프로세스는 항상 프로세스 ID (PID) 1을 가지며, 커널이 부팅 과정에서 직접 실행하는 첫 번째 사용자 공간 프로세스입니다. 모든 다른 프로세스는 이 프로세스의 자식 또는 자손이 되며, 이는 리눅스의 프로세스 관리 구조의 근간이 됩니다.

init(또는 systemd) 프로세스의 주요 역할은 다음과 같습니다.
1. 시스템 초기화: 부팅 과정에서 다른 프로세스들을 시작하고, 시스템을 적절한 실행 레벨로 가져갑니다.
2. 고아 프로세스 관리: 부모 프로세스가 종료된 프로세스들의 새로운 부모가 되어 관리합니다.
3. 좀비 프로세스 정리: 주기적으로 wait() 시스템 콜을 호출하여 종료된 자식 프로세스의 상태를 수집합니다.
4. 서비스 관리: 시스템 서비스의 시작, 중지, 재시작을 관리하며, 서비스 간의 의존성도 관리합니다.

이 프로세스는 시스템의 안정성을 위해 SIGKILL을 포함한 대부분의 시그널에 의해 종료되지 않도록 설계되어 있습니다.
 systemd의 경우, 전통적인 init 시스템에 비해 병렬 처리를 통한 부팅 속도 향상, 향상된 의존성 관리, 통합된 로깅 시스템 등 추가적인 기능을 제공하빈다.

