# 컨텍스트 스위칭
컨텍스트 스위칭은 멀티태스킹 운영체제의 핵심 기능 중 하나입니다.

## 컨텍스트란?
컨텍스트는 프로세스나 스레드의 현재 상태를 나타내는 정보의 집합입니다.
- 프로그램 카운터(PC): 다음에 실행할 명령어의 메모리 주소
- 레지스터 값들: CPU 내부의 임시 저장소 값들
- 스택 포인터: 현재 스택의 top을 가리키는 포인터
- 메모리 맵: 프로세스가 사용 중인 메모리 영역 정보

1. 컨테스트의 정의와 구성 요소
- 컨텍스트는 프로세스나 스레드의 현재 실행 상태를 완전히 설명하는 데 필요한 모든 정보를 포함합니다.
- CPU 레지스터 상태
  - 프로그램 카운터(PC): 다음에 실행할 명령어의 메모리 주소
  - 스택 포인터(SP): 현재 스택의 top을 가리키는 포인터
  - 범용 레지스터: 연산에 사용되는 임시 데이터 저장소
  - 상태 레지스터: CPU의 현재 상태 플래스 (예: 제로 플래그, 캐리 플래그 등)
- 메모리 관리 정보
  - 페이지 테이블: 가상 메모리 주소를 물리적 메모리 주소로 변환하는 데 사용
  - 세그먼트 테이블: 세그먼트 기반 메모리 관리에서 사용
- I/O 상태
  - 열린 파일 목록: 프로세스가 현재 사용 중인 파일 디스크립터
  - 네트워크 연결 상태: 활성화된 소켓 정보 등
- 계정 정보
  - 프로세스 ID (PID)
  - 부모 프로세스 ID (PPID)
  - 사용자 ID, 그룹 ID
- 프로세스 간 통신(IPC) 정보
  - 메시지 큐
  - 공유 메모리 세그먼트
  - 세마포어 상태
2. 컨텍스트의 심층 이해
- 하드웨어 컨텍스트 vs 소프트웨어 컨텍스트
  - 하드웨어 컨텍스트: CPU 레지스터와 같이 하드웨어에 직접 관련된 정보
  - 소프트웨어 컨텍스트: 운영체제가 관리하는 프로세스 관련 정보 (예: 열린 파일 목록)
- 컨텍스트의 계층적 구조
  - 사용자 모드 컨텍스트: 응용 프로그램 수준의 정보
  - 커널 모드 컨텍스트: 운영체제 커널 수준의 정보
- 컨텍스트의 동적 특성
  - 컨텍스트는 프로세스 실행 중 지속적으로 변화
  - 예: 함수 호출 시 스택 포인터와 프로그램 카운터 변경
3. 컨텍스트와 프로세스 제어 블록의 관계
PCB는 운영체제가 프로세스를 관리하기 위해 유지하는 자료구조로, 컨텍스트 정보의 대부분을 포함합니다.
- PCB의 구조
  - 프로세스 식별자
  - 프로세스 상태
  - 프로그램 카운터
  - CPU 레지스터
  - CPU 스케줄링
  - 메모리 관리 정보
  - 계정 정보
  - I/O 상태 정보
- PCB와 컨텍스트 스위칭
  - 컨텍스트 스위칭 시 현재 프로세스의 컨텍스트를 PCB에 저장
  - 새 프로세스 실행 시 해당 프로세스의 PCB에서 컨텍스트 복원
4. 컨텍스트의 중요성
- 멀티태스킹의 기반
  - 컨텍스트 저장과 복원을 통해 여러 프로세스의 동시 실행 가능
- 프로세스 격리
  - 각 프로세스의 컨텍스트를 분리 관리하여 프로세스 간 독립성 보장
- 시스템 복원력
  - 시스템 크래시 시 마지막 저장된 컨텍스트를 이용해 복구 가능
5. 고급 주제: 컨텍스트 가상화
- 가상 머신(VM)에서의 컨텍스트
  - 하이퍼바이저가 각 VM의 컨텍스트를 관리
  - 네스티드 가상화에서는 다중 레벨의 컨텍스트 관리 필요
- 컨테이너와 컨텍스트
  - 컨테이너는 호스트 OS와 컨텍스트를 공유하면서도 격리된 환경 제공
6. 비유

컨텍스트는 책갈피에 비유할 수 있습니다. 여러 책을 동시에 읽을 때, 각 책에 책갈피를 꽂아두면 나중에 어디까지 읽었는지 바로 알 수 있습니다.
컨텍스트는 이와 같이 프로세스의 '현재 페이지'를 표시해주는 역할을 합니다.

### 컨텍스트의 크기는 얼마나 되나요?
- 컨텍스트의 크기는 시스템 아키텍처와 운영체제에 따라 다르지만, 일반적으로 수 킬로바이트에서 수십 킬로바이트 정도입니다.
### 컨텍스트 정보는 어디에 저장되나요?
- 실행 중인 프로세스의 컨텍스트는 CPU 레지스터에 있습니다. 컨텍스트 스위칭 시에는 메모리의 PCB로 이동합니다.
### 사용자 모드와 커널 모드 컨텍스트의 차이점은?
- 사용자 모드 컨텍스트는 응용 프로그램 레벨의 정보만 포함하지만, 커널 모드 컨텍스트는 시스템 리소스에 대한 접근 권한 등 더 민감한 정보를 포함합니다.

## 컨텍스트 스위칭이란?
CPU가 하나의 프로세스나 스레드에서 다른 프로세스나 스레드로 제어를 전환하는 과정을 말합니다. 
이 과정에서 현재 실행 중인 프로세스의 컨텍스트르 저장하고, 다음에 실행핦 프로세스의 컨텍스트를 복원합니다.

1. 컨텍스트 스위칭의 정의

컨텍스트 스위칭은 운영체제가 현재 실행 중인 프로세스나 스레드를 중단하고 다른 프로세스나 스레드를 실행하기 위해 CPU 제어권을 전환하는 과정입니다. 이 과정에서 현재 실행 중인 프로세스의 상태(컨텍스트)를 저장하고, 다음에 실행할 프로세스의 상태를 복원합니다.
2. 컨텍스트 스위칭의 상세 과정
- 현재 프로세스 상태 저장
  - CPU 레지스터 값들을 프로세스 제어 블록에 저장
  - 메모리 관리 정보 (예: 페이지 테이블 포인터) 저장
  - I/O 상태 정보 저장
- 새 프로세스 선택
  - 스케줄러가 실행 대기 중인 프로세스 중 하나를 선택
- 새 프로세스 상태 복원
  - 선택된 프로세스의 PCB에서 CPU 레지스터 값 복원
  - 메모리 관리 정보 복원 (예: 페이지 테이블 전환)
  - I/O 상태 정보 복원
- CPU 제어권 전환
  - 프로그램 카운터를 새 프로세스의 다음 실행 지점으로 설정
3. 컨텍스트 스위칭의 유형
- 프로세스 간 스위칭
  - 완전한 컨텍스트 스위칭 필요
  - 메모리 관리 단위(MMU) 재구성 필요
- 스레드 간 스위칭
  - 같은 프로세스 내 스레드 간 전환은 더 가벼움
  - 메모리 컨텍스트 유지, CPU 레지스터만 전환
- 커널 수준 vs 사용자 수준 스위칭
  - 커널 수준: 운영체제 개입 필요, 더 무거움
  - 상요자 수준: 라이브러리에 의해 관리, 더 가벼움
4. 컨텍스트 스위칭 트리거 요인
- 시간 분할 만료
  - 라운드 로빈 스케줄링에서 프로세스의 할당 시간 종료 시
- 우선순위 기반 선점
  - 더 높은 우선순위의 프로세스가 실행 준비될 때
- I/O 요청 또는 시스템 콜
  - 프로세스가 I/O 작업을 요청하고 대기 상태로 전환될 때
- 동기화 이벤트
  - 세마포어 대기, 뮤텍스 잠금 등으로 인한 블로킹
5. 컨텍스트 스위칭의 오버헤드
- 직접적인 비용
  - CPU 시간 소모: 컨텍스트 저장 및 복원에 사용되는 시간
  - 메모리 사용: PCB 저장에 필요한 메모리
- 간접적인 비용
  - 캐시 오염: 캐시 내용이 새 프로세스의 데이터로 대체
  - TLB(Translation Lookaside Buffer) 플러시: 주소 변환 캐시 무효화
  - 파이프라인 플러시: CPU 명령어 파이프라인 재구성
  - 분기 예측기 재설정: 새 프로세스의 코디 실행 시 분기 예측 정확도 저하
  - NUMA(Non-Uniform Memory Access) 시스템에서의 메모리 지역성 손실: 프로세스가 다른 NUMA 노드의 CPU로 이동 시 ㅔ모리 접근 latency 증가
6. 컨텍스트 스위칭 최적화 기법
- 프로세스 친화도 스케줄링
  - 프로세스를 이전에 실행되었던 CPU 코어에 할당하여 캐시 효율성 증대
- 공유 메모리 및 메시지 패싱
  - 프로세스 간 통신을 위한 효율적인 메커니즘 제공
- 경량 프로세스 및 스레드 사용
  - 전체 프로세스 컨텍스트 스위칭보다 가벼운 스레드 전환 활용
- 비동기 I/O 및 이벤트 기반 프로그래밍
  - I/O 대기로 인한 불피욯나 컨텍스트 스위칭 감소
7. 비유

컨텍스트 스위칭은 레스토랑 주방에서 여러 요리를 동시에 만드는 상황과 비슷합니다. 
셰프(CPU)가 파스타 요리에서 스테이크 요리로 전환할 때, 파스타의 현재 상태(컨텍스트)를 메모해두고(PCB에 저장), 스테이크 요리의 레시피와 진행 상황(새 프로세스의 컨텍스트)를 확인한 후 요리를 시작합니다.

### 컨텍스트 스위칭 빈도는 어떻게 결정되나요?
운영체제의 스케줄링 알고리즘, 시스템 부하, 프로세스의 특성 등에 따라 결정됩니다. 일반적으로 밀리초 단위로 발생합니다.
### 컨텍스트 스위칭이 너무 자주 일어나면 어떻게 되나요?
시스템 성능이 저하될 수 있습니다. 실제 작업보다 컨텍스트 스위칭에 더 많은 시간을 소비하는 스래싱(thrashing) 현상이 발생할 수 있습니다.
### 실시간 시스템에서의 컨텍스트 스위칭은 어떻게 다르나요?
실시간 시스템에서는 예측 가능한 컨텍스트 스위칭이 중요합니다. 우선순위 기반 선점형 스케줄링을 사용하여 중요한 태스크의 즉각적인 실행을 보장합니다.

## 컨텍스트 스위칭이 필요한 이유
- 멀티태스킹: 여르 프로세스를 동시에 실행하는 것처럼 보이게 하기 위해
- 시분할 시스템: CPU 시간을 여러 프로세스에 공평하게 분배하기 위해
- 인터럽트 처리: 긴급한 작업(예: I/O 완료)을 즉시 처리하기 위해

1. 멀티태스킹 지원
- 시분할 시스템
  - 여러 프로세스가 CPU 시간을 공유하여 동시에 실행되는 것처럼 보이게 함
  - 사용자에게 시스템이 독점적으로 사용되는 듯한 환상을 제공
  - 예: 여러 응용 프로그램을 동시에 실행하는 데스크톱 환경
- 공정성
  - 모든 프로세스에 CPU 시간을 공평하게 할당
  - 특정 프로세스가 CPU를 독점하는 것을 방지
  - 예: 라운드 로빈 스케줄링 알고리즘
- 우선순위 기반 실행
  - 중요도나 긴급성에 따라 프로세스에 우선순위 부여
  - 높은 우선순위의 작업이 더 빨리, 자주 실행되도록 함
  - 예: 실시간 시스템에서의 긴급 태스크 처리
2. 리소스 활용 최적화
- CPU 유휴 시간 최소화
  - I/O 바운드 프로세스가 대기 중일 때 다른 프로세스 실행
  - CPU 사용률 향상
  - 예: 디스크 I/O를 기다리는 동안 다른 계산 작업 수행
- 병렬성 활용
  - 멀티코어 시스템에서 여러 프로세스를 동시에 실행
  - 시스템 전체의 처리량 향상
  - 예: 웹 서버에서 여러 클라이언트 요청 동시 처리
3. 시스템 반응성 향상
- 사용자 상호작용 처리
  - 사용자 입력에 빠르게 반응하기 위해 현재 작업을 중단하고 입력 처리
  - GUI 시스템의 부드러운 작동 보장
  - 예: 텍스트 편집기에서 타이핑 중 백그라운드 저장 작업
- 실시간 시스템 요구사항 충족
  - deadline이 있는 작업을 적시에 처리
  - 중요한 이벤트에 신속하게 대응
  - 예: 자동차 제어 시스템에서의 긴급 브레이크 신호 처리
4. 인터럽트 처리
- 하드웨어 이벤트 대응
  - 외부 장치로부터의 신호에 즉시 반응
  - 시스템의 효율적인 I/O 처리
  - 예: 네트워크 패킷 도착 시 즉시 처리
- 소프트웨어 인터럽트(트랩) 처리
  - 시스템 콜이나 예외 상황에 대응
  - 사용자 모드와 커널 모드 간의 전환
  - 예: 파일 읽기 시스템 콜 처리
5. 동기화 및 프로세스 간 통신
- 프로세스 동기화
  - 공유 리소스에 대한 접근 조정
  - 데드락이나 레이스 컨디션 방지
  - 예: 뮤텍스나 세마포어를 이용한 임계 영역 보호
- 프로세스 간 통신(IPC) 지원
  - 메시지 전달이나 공유 메모리를 통한 프로세스 간 데이터 교환
  - 협력 작업 수행
  - 예: 파이프를 통한 프로세스 간 데이터 스트림 전송
6. 시스템 안정성 및 보안
- 프로세스 격리
  - 한 프로세스의 오류가 전체 시스템에 영향을 미치는 것을 방지
  - 각 프로세스에 독립적인 메모리 공간 제공
  - 예: 웹 브라우저에서 한 탭의 충돌이 다른 탭에 영향을 주지 않음
- 권한 분리
  - 사용자 모드와 커널 모드 분리
  - 중요한 시스템 리소스에 대한 접근 제어
  - 예: 사용자 프로세스가 직접 하드웨어에 접근하는 것을 방지

7. 비유

컨텍스트 스위칭은 교통 신호등과 같습니다. 신호등이 없다면 한 방향의 차량만 계속 지나갈 것입니다.(단일 프로세스 실행)
하지만 신호등(컨텍스트 스위칭)을 통해 여러 방향의 차량(다양한 프로세스)이 효율적으로 그리고 공평하게 도로(CPU)를 사용할 수 있습니다.
또한, 긴급 차량(높은 우선순위 프로세스)이 오면 신호를 조정하여 우선 통과시킬 수 있습니다.

### 컨텍스트 스위칭 없이 멀티태스킹이 가능한가요?
진정한 의미의 멀티태스킹은 불가능합니다. 하지만 멀티코어 시스템에서는 각 코어가 다른 프로세스를 실행함으로써 부분적인 멀티태스킹이 가능합니다.
### 실시간 시스템에서 컨텍스트 스위칭은 어떻게 다르게 동작하나요?
실시간 시스템에서는 deadline을 보장하기 위해 더 예측 가능한 컨텍스트 스위칭이 필요합니다.
우선순위 기반 선점형 스케쥴링을 사용하여 중요한 태스크의 즉각적인 실행을 보장합니다.
### 컨텍스트 스위칭의 빈도를 어떻게 결정하나요?
운영체제의 스케줄링 알고리즘, 시스템 부하, 프로세스의 특성 등에 따라 결정됩니다. 너무 빈번한 스위칭은 오버헤드를 증가시키고, 너무 드문 스위칭은 반응성을 떨어뜨릴 수 있어 적절한 균형이 필요합니다.

## 컨텍스트 스위칭 과정
1. 현재 실행 중인 프로세스 A의 컨텍스트를 PCB에 저장
2. 프로세스 A를 준비 큐로 이동
3. 다음에 실행할 프로세스 B를 선택(스케쥴링)
4. 프로세스 B의 컨텍스트를 PCB에서 불러와 CPU 레지스터에 복원
5. 프로세스 B의 실행 시작

## 컨텍스트 스위칭의 오버헤드 컨텍스트 스위칭은 필수적이지만 비용이 듭니다.
- CPU 시간 소비: 컨텍스트 저장 및 복원 시간 소요
- 캐시 미스: 프로세스 전환 시 내용이 무효화될 수 있음
- TLB(Translation Lookaside Buffer) 플러시: 메모리 주소 변환 정보 갱신 필요

## 컨텍스트 스위칭 최적화 방법
- 스레드 사용: 같은 프로세스 내 스레드 간 전환은 더 가벼움
- 프로세스 친화도(affinity): 특정 CPU에 프로세스를 고정해 캐시 효율성 향상
- 컨텍슽트 스위칭 빈도 조절: 타임 슬라이스 크기 조정

1. 하드웨어 수준 최적화
- 프로세서 아키텍처 개선
  - 전용 컨텍스트 스위칭 명령어 제공
  - 효과: 사용자 모드와 커널 모드 전환 시간 단축
- 레지스터 뱅크 증가
  - 여러 프로세스의 컨텍스트를 동시에 유지
  - 효과: 레지스터 저장/복원 시간 감소
- 캐시 및 TLB 최적화
  - 프로세스 ID 태그가 있는 캐시 라인
  - 효과: 컨텍스트 스위칭 시 캐시 및 TLB 플러시 최소화
2. 운영체제 수준 최적화
- 스케줄링 알고리즘 개선
  - 지능적인 타임 슬라이스 할당
  - 효과: 불필요한 컨텍스트 스위칭 감소
- 프로세스 친화도 스케줄링
  - 프로세스를 특정 CPU 코어에 고정
  - 효과: 캐시 지역성 향상, TLB 히드율 증가
- 스레드 클러스터링
  - 관련 스레드를 같은 CPU 캐시를 공유하는 코어에 배치
  - 효과: 캐시 간 데이터 이동 최소화
- 커널 선점 관리
  - 중요한 커널 작업 중 빌필요한 컨텍스트 스위칭 방지
  - 효과: 커널 작업의 효율성 증가
3. 메모리 관리 최적화
- 대용량 페이지 사용
  - 기본 4KB 페이지 대신 2MB 또는 1GB 페이지 사용
  - 효과: TLB 미스 감소, 페이지 테이블 워크 횟수 감소
- 메모리 압축
  - 사용하지 않는 메모리 페이지를 압축하여 저장
  - 효과: 스왑 I/O 감소, 메모리 효율성 증가
- NUMA(Non-Uniform Memory Access) 인식 메모리 할당
  - 프로세스가 실행되는 CPU에 가까운 메모리 노드에 할당
  - 효과: 메모리 접근 지연시간 감소
4. I/O 인터럽트 최적화
- 인터럽트 조절
  - 여러 인터럽트를 그룹화하여 처리
  - 효과: 인터럽트로 인한 컨텍스트 스위칭 감소
- I/O 스케줄러 최적화
  - I/O 요청을 효율적으로 병합 및 정렬
  - 효과: I/O 대기로 인한 컨텍스트 스위칭 감소
- 비동기 I/O 및 이벤트 기반 프로그래밍
  - 블로킹 I/O 대신 비동기 I/O 사용
  - 효과: I/O 대기 중 불필요한 컨텍스트 스위칭 방지
5. 애플리케이션 수준 최적화
- 경량 스레드 사용
  - 커널 스레드 대신 사용자 수준 스레드 사용
  - 효과: 스레드 전환 비용 감소
- 작업 배치
  - 여러 작은 작업을 하나의 큰 작업으로 묶어 처리
  - 효과: 시스템 콜 및 컨텍스트 스위칭 횟수 감소
- 락-프리 알고리즘 사용
  - 동기화를 위한 락 대신 원자적 연산 사용
  - 효과: 락 획득/해제로 인한 컨텍스트 스위칭 감소
6. 비유

컨텍스트 스위칭 최적화는 공장의 생산 라인 효율화와 비슷합니다. 하드웨어 수준 최적화는 더 빠른 기계(CPU)를 사용하는 것과 같고, 운영체제 수준 최적화는 작업 스케줄을 개선하는 것과 같습니다.
메모리 관리 최적화는 부품(데이터)를 효율적으로 배치하는 것이고, I/O 최적화는 자제 공급(데이터 입출력)을 원활하게 하는 것입니다. 
마지막으로 애플리케이션 수준 최적화는 작업자(프로그램)가 더 효율적으로 일하는 방법을 배우는 것과 같습니다.

### 모든 최적화 기법을 동시에 적용할 수 있나요?
모든 기법을 동시에 적용하는 것은 가능하지만, 시스템의 특성과 워크로드에 따라 일부 기법은 서로 상충될 수 있습니다.
### 컨텍스트 스위칭 최적화의 단점은 없나요?
일부 최적화 기법(예: 대용량 페이지)은 메모리 사용량을 증가시킬 수 있습니다. 또한, 과도한 최적화는 시스템의 복잡성을 증가시키고 디버깅을 어렵게 만들 수 있습니다.
### 어떤 최적화 기법이 가장 효과적인가요?
이는 시스템 특성과 워크로드에 크게 의존합니다. 일반적으로 하드웨어 수준의 최적화와 스케줄링 알고리즘 개선이 큰 영향을 미치지만, 구체적인 상황에 따라 다른 기법이 더 효과적일 수 있습니다.

### 컨텍스트 스위칭과 멀티코어 프로세서의 관계는?
- 멀티코어에서는 실제로 동시에 여러 프로세스를 실행할 수 있어 컨텍스트 스위칭 빈도를 줄일 수 있습니다. 하지만 여전히 코어 수보다 많은 프로세스를 처리할 때는 컨텍스트 스위칭이 필요합니다.
### 컨텍스트 스위칭 시간은 얼마나 걸리나요?
- 하드웨어와 운영체제에 따라 다르지만, 일반적으로는 마이크로초 단위입니다.
### 사용자 수준 스레드와 커널 수준 스레드의 컨텍스트 스위칭 차이는?
- 사용자 수준 스레드 전환은 커널의 개입 없이 이루어져 더 빠르지만, 하나의 스레드가 블로킹되면 전체 프로세스가 블로킹될 수 있습니다. 커널 수준 스레드는 운영체제가 직접 관리하여 더 유연하지만 전환 비용이 더 큽니다.