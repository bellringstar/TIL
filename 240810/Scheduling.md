# 스케쥴링 알고리즘
> 스케줄링 알고리즘은 마치 바쁜 식당의 주방장과 같습니다. 주방에는 여러 요리사(프로세스)가 있고, 각자 다른 요리(작업)를 준비하고 있습니다. 주방장(운영체제)은 제한된 조리대(CPU)를 가장 효율적으로 사용하여 모든 요리를 적시에 완성해야 합니다. 어떤 요리사에게 조리대를 먼저 줄지, 얼마나 오래 사용하게 할지를 결정하는 것이 바로 스케줄링 알고리즘의 역할입니다.

## 기본 개념 이해
### 프로세스와 스레드의 개념
#### 프로세스
프로세스는 실행 중인 프로그램의 인스턴스입니다. 더 구체적으로 프로세스는 다음 요소들로 구성됩니다.
- 코드 세그먼트 (프로그램 명령어)
- 데이터 세그먼트 (전역 변수)
- 스택 (지역 변수, 함수 호출 정보)
- 힙 (동적으로 할당된 메모리)
- 프로그램 카운터, 레지스터 값 등의 프로세스 상태 정보

프로세스는 운영체제로부터 독립적인 메모리 공간을 할당받아 실행됩니다. 이는 한 프로세스가 다른 프로세스의 메모리를 직접 접근할 수 없음을 의미합니다.

#### 스레드
스레드는 프로세스 내에서 실행되는 더 작은 실행 단위입니다. 한 프로세스는 여러 개의 스레드를 가질 수 있으며, 이들은 프로세스의 자원을 공유합니다.
- 같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유합니다.
- 각 스레드는 자신만의 스택과 레지스터 세트를 가집니다.
- 스레드 간 통신이 프로세스 간 통신보다 더 효율적입니다.

### CPU 버스트와 I/O 버스트
프로세스의 실행은 CPU 실행(계산)과 I/O 대기의 사이클로 이루어집니다.
#### CPU 버스트
- CPU를 사용하여 명령어를 실행하는 기간
- 계산 집약적인 작업 수행 (예: 수학 연산, 데이터 처리)

#### I/O 버스트
- 입출력 작업을 기다리는 기간
- 디스크 읽기/쓰기, 네트워크 통신 등의 작업

#### 프로세스의 특성에 따라 CPU 버스트와 I/O 버스트의 비율이 다릅니다.
- CPU-bound 프로세스: CPU 버스트가 긴 프로세스 (예: 과학 계산, 렌더링)
- I/O-bound 프로세스: I/O 버스트가 긴 프로세스 (예: 데이터베이스 서버, 파일 복사)

### 선점형과 비선점형 스케줄링
#### 선점형 스케줄링
- 운영체제가 실행 중인 프로세스로부터 강제로 CPU를 빼앗아 다른 프로세스에 할당할 수 있는 방식
- 장점: 높은 우선순위 프로세스의 빠른 응답 가능, 시분할 시스템 구현에 적합
- 단점: 문맥 교환 오버헤드 발생, 공유 자원 접근 시 동기화 문제 발생 가능
#### 비선점형 스케줄링
- 한 번 CPU를 할당받은 프로세스는 자발적으로 CPU를 반환하거나 작업을 마칠 때까지 계속 실행되는 방식
- 장점: 문맥 교환 오버헤드가 적음, 공유 자원 접근 시 동기화 문제가 덜 발생
- 단점: 긴 작업이 시스템을 독점할 수 있음, 실시간 시스템에 부적합

### 질의응답
1. 프로세스와 스레드의 주요 차이점은 무엇인가요?
- 프로세스는 독립적인 메모리 공간과 자원을 가지는 반면, 스레드는 같은 프로세스 내에서 코드, 데이터, 힙 영역을 공유합니다. 프로세스는 더 많은 자원을 사용하지만 더 안전하고, 스레드는 더 가볍고 통신이 효율적입니다.
2. CPU-bound 프로세스와 I/O-bound 프로세스의 차이점은 무엇이며, 이들을 어떻게 다르게 스케줄링해야 할까요?
- CPU-bound 프로세스는 계산 작업이 많아 CPU 사용이 많고, I/O-bound 프로세스는 입출력 작업이 많습니다. CPU-bound 프로세스는 긴 시간 할당이 효율적이고, I/O-bound 프로세스는 빠른 응답시간이 중요하므로 짧은 시간 할당이 적합할 수 있습니다.
3. 선점형 스케줄링의 장단점은 무엇인가요?
- 장점은 높은 우선순위 작업의 빠른 처리와 시분할 시스템 구현이 가능하다는 것입니다. 단점은 잦은 문맥 교환으로 인한 오버헤드와 공유 자원 접근 시 동기화 문제가 발생할 수 있다는 것입니다.
## 스케줄링 기준
### CPU 사용률
전체 시스템 시간 중 CPU가 작업을 처리하는 데 사용된 시간의 비율
- 목표는 CPU 사용률을 최대화하는 것입니다. 이상적으로는 100%에 가까울수록 좋습니다.
- 실제로는 40% ~ 90% 사이가 일반적이며, 시스템의 용도에 따라 다릅니다.
- 낮은 CPU 사용률은 시스템 자원이 효율적으로 사용되지 않고 있음을 의미합니다.
- CPU 사용률 = (CPU 바쁜 시간 / 총 시간) * 100%

### 처리량
단위 시간당 완료되는 프로세스의 수
- 높은 처리량은 시스템이 효율적으로 작업을 처리하고 이씀을 나타냅니다.
- 긴 프로세스보다 짧은 프로세스를 우선적으로 처리하면 처리량을 증가시킬 수 있습니다.
- 그러나 이는 다른 기준들과 균형을 이루어야 합니다.
- 처리량 = 완료된 프로세스 수 / 경과 시간

### 대기 시간
프로세스가 준비 큐에서 대기하는 총 시간
- 짧은 대기 시간은 시스템의 응답성이 좋다는 것을 의미합니다.
- 대기 시간을 줄이면 전체적인 시스템 성능이 향상됩니다.
- 특히 대화형 시스템에서 중요한 지표입니다.
- 대기 시간 = (프로세스 종료 시간 - 프로세스 도착 시간) - 실제 실행 시간

### 응답 시간
요청이 제출된 시점부터 첫 번째 응답이 생성되기까지의 시간
- 대화형 시스템에서 특히 중요한 지표입니다.
- 짧은 응답 시간은 사용자 경험을 향상시킵니다.
- 배치 처리 시스템보다 시분할 시스템에서 더 중요합니다.
- 응답시간 = 첫 번째 응답 시간 - 요청 제출 시간

### 공정성
모든 프로세스가 공평하게 CPU 시간을 할당받는 정도
- 완벽한 공정성은 모든 프로세스가 동일한 CPU 시간을 받는 것을 의미합니다.
- 그러나 실제로는 프로세스의 우선순위나 특성에 따라 차등을 두는 것이 효율적일 수 있습니다.
- 기아 상태를 방지하는 것이 중요합니다.
- 프로세스 간 CPU 할당 시간의 표준 편차 등을 사용할 수 있습니다.

이러한 기준들은 서로 trade-off가 있을 수 있습니다. 예를 들어, 처리량을 높이려고 하면 응답 시간이 길어질 수 있습니다.

### 질의응답
1. CPU 사용률과 처리량 중 어느 것이 더 중요한가요?
- 이는 시스템의 목적에 따라 다릅니다. 배치 처리 시스템에서는 CPU 사용률과 처리량이 중요할 수 있지만, 대화형 시스템에서는 응답 시간이 더 중요할 수 있습니다. 일반적으로 두 지표를 모두 고려하여 최적의 균형을 찾는 것이 중요합니다.
2. 대기 시간과 응답 시간의 차이는 무엇인가요?
- 대기 시간은 프로세스가 준비 큐에서 기다리는 총 시간을 의미하며, 응답 시간은 요청이 제출된 시점부터 첫 번째 응답이 나올 때까지의 시간을 의미합니다. 응답 시간에는 대기 시간 외에도 프로세스의 실행 시작부터 첫 출력까지의 시간이 포함됩니다.
3. 공정성을 어떻게 측정하고 보장할 수 있을까요?
- 공정성은 프로세스 간 CPU 할당 시간의 표준 편차 등을 통해 측정할 수 있습니다. 완벽한 공정성보다는 기아 상태를 방지하는 것이 더 중요합니다. 이를 위해 에이징 기법을 사용하거나, 다단계 피드백 큐와 같은 스케줄링 알고리즘을 활용할 수 있습니다.

## 주요 스케줄링 알고리즘
### 선입선출(FIFO) 또는 First-Come, First-Served (FCFS)
- 원리
  - 가장 간단한 스케줄링 알고리즘으로, CPU 요청 순서대로 프로세스를 실행합니다.
  - 비선점형 알고리즘입니다.
- 장점
  - 구현이 간단하고 공평합니다.
  - 새로운 프로세스의 추가가 쉽습니다.
- 단점
  - 평균 대기 시간이 길 수 있습니다.
  - 짧은 프로세스가 긴 프로세스 뒤에서 오래 기다려야 하는 "convoy effect"가 발생할 수 있습니다.

### 최단 작업 우선(SJF: Shortest Job First)
- 원리
  - CPU 버스트 시간이 가장 짧은 프로세스를 먼저 실행합니다.
  - 선점형과 비선점형 두 가지 버전이 있습니다.
- 장점
  - 평균 대기 시간을 최소화합니다.
  - 짧은 작업에 대해 빠른 응답 시간을 제공합니다.
- 단점
  - CPU 버스트 시간을 미리 알아야 하는데, 이는 실제로는 어렵습니다.
  - 긴 프로세스가 계속 뒤로 밀려나는 기아 현상이 발생할 수 있습니다.

### 우선순위 스케줄링(Priority Scheduling)
- 원리
  - 각 프로세스에 우선순위를 할당하고, 가장 높은 우선순위의 프로세스를 먼저 실행합니다.
  - 선점형과 비선점형 두 가지 버전이 있습니다.
- 장점
  - 중요한 작업을 먼저 처리할 수 있습니다.
  - 시스템의 요구사항에 따라 유연하게 조정 가능합니다.
- 단점
  - 낮은 우선순위의 프로세스가 실행되지 못하는 기아 현상이 발생할 수 있습니다.
  - 우선순위 결정 메커니즘이 복잡할 수 있습니다.

### 라운드 로빈
- 원리
  - 각 프로세스에 작은 단위의 CPU 시간(타임 퀀텀)을 할당하고, 이 시간이 지나면 다음 프로세스로 전환합니다.
  - 선점형 알고리즘입니다.
- 장점
  - 모든 프로세스가 공평하게 CPU 시간을 할당받습니다.
  - 응답 시간이 빠릅니다.
- 단점
  - 타임 퀀텀 설정이 중요합니다. 너무 크면 FCFS와 비슷해지고, 너무 작으면 컨텍스트 스위칭 오버헤드가 커집니다.
  - 프로세스의 중요도를 고려하지 않습니다.

### 다단계 큐
- 원리
  - 프로세스들을 여러 그룹으로 나누고, 각 그룹에 다른 우선순위를 부여합니다.
  - 각 큐는 자체적인 스케줄링 알고리즘을 가질 수 있습니다.
- 장점
  - 다양한 유형의 프로세스를 효율적으로 처리할 수 있습니다.
  - 각 큐의 특성에 맞는 스케줄링 알고리즘을 적용할 수 있습니다.
- 단점
  - 큐 간 스케줄링이 복잡할 수 있습니다.
  - 낮은 우선순위 큐의 기아 현상이 발생할 수 있습니다.

### 다단계 피드백 큐
- 원리
  - 다단계 큐의 확장 버전으로, 프로세스가 큐 사이를 이동할 수 있습니다.
  - 일반적으로 CPU 버스트가 짧은 프로세스를 높은 우선순위 큐로 이동시킵니다.
- 장점
  - 다양한 유형의 작업을 효율적으로 처리할 수 있습니다.
  - CPU 버스트 시간을 예측할 필요가 없습니다.
- 단점
  - 가장 복잡한 알고리즘 중 하나로, 구현과 관리가 어려울 수 있습니다.
  - 매개변수 설정이 시스템 성능에 큰 영향을 미칩니다.

### 질의응답
1. 왜 대부분의 현대 운영체제는 순수한 FCFS나 SJF 대신 더 복잡한 알고리즘을 사용합니다.
- FCFS는 긴  프로세스가 시스템을 독점할 수 있고, SJF는 CPU 버스트 시간 예측이 어렵고 기아 현상이 발생할 수 있기 때문입니다. 현대 시스템은 다양한 유형의 프로세스를 공정하고 효율적으로 처리해야 하므로, 라운드 로빈이나 다단계 피드백 큐와 같은 더 복잡한 알고리즘이 필요합니다.
2. 라운드 로빈에서 적절한 타임 퀀텀을 어떻게 결정합니다.
- 타임 퀀텀 설정은 시스템의 특성과 요구사항에 따라 다릅니다 일반적으로 컨텍스트 스위칭 오버헤드와 응답 시간 사이의 균형을 고려합니다. 보통 10~100 밀리초 범위에서 설정되며, 실험과 성능 측정을 통해 최적값을 찾습니다.
3. 다단계 피드백 큐 알고리즘에서 기아 현상을 어떻게 방지할 수 있나요?
- aging 기법을 사용할 수 있습니다. 이는 프로세스가 대기하는 시간이 길어질수록 점진적으로 우선순위를 높여주는 방식입니다. 또한, 주기적으로 모든 프로세스를 최상위 큐로 이동시키느 방법도 있습니다.

## 실시간 스케줄링
실시간 스케줄링은 시간 제약이 있는 작업을 처리하기 위한 특별한 형태의 스케줄링입니다.
### 경성 실시간 시스템 (Hard Real-Time Systems)
- 정의
  - 모든 작업(태스크)이 반드시 정해진 기한(deadline) 내에 완료되어야 하는 시스템입니다.
  - 기한을 어기면 시스템 실패로 간주되며, 심각한 결과를 초래할 수 있습니다.
- 특징
  - 예측 가능성과 결정론적 행동이 매우 중요합니다.
  - 최악의 경우 실행 시간(Worst-Case Execution Time, WCET)을 고려하여 설계됩니다.
  - 오버로드 상황에서도 중요한 태스크의 실행을 보장해야 합니다.
- 비행기 제어 시스템, 자동차 에어백 시스템, 의료 장비 등

#### 주요 스케줄링 알고리즘
1. Rate Monotonic (RM)
- 주기적 태스크에 대해, 주기가 짧을수록 높은 우선순위를 부여합니다.
- 정적 우선순위 알고리즘으로, 구현이 간단합니다.
2. Earliest Deadline First (EDF)
- 마감 시간이 가장 가까운 태스크에 가장 높은 우선순위를 부여합니다.
- 동적 우선순위 알고리즘으로, RM보다 CPU 이용률이 높습니다.

### 연성 실시간 시스템 (Soft Real-Time Systems)
- 정의
  - 대부분의 태스크가 기한 내에 완료되어야 하지만, 일부 기한 미준수가 허용되는 시스템입니다.
  - 기한을 어겨도 시스템이 계속 작동하며, 성능 저하만 발생합니다.
- 특징
  - 평균 성능이 중요하며, 일부 지연이 허용됩니다.
  - 통계적 보장을 제공합니다 (예: 99%의 태스크가 기한 내 완료").
  - 일반적인 운영체제에서 실시간 기능을 추가하여 구현할 수 있습니다.
- 스트리밍 미디어 시스템, 온라인 게임, 전화 교환 시스템 등

#### 주요 스케줄링 기법
1. 우선순위 기반 선점형 스케줄링
- 일반적인 우선순위 스케줄링에 실시간 특성을 추가합니다.
2. 최선의 노력 스케줄링
- 가능한 많은 태스크를 기한 내에 완료하려고 노력합니다.

### 실시간 스케줄링의 주요 고려사항
1. 예측 가능성: 시스템의 동작이 예측 가능해야 합니다.
2. 응답성: 외부 이벤트에 빠르게 반응할 수 있어야 합니다.
3. 사용자 제어: 프로그래머가 태스크의 상대적 중요도를 지정할 수 있어야 합니다.
4. 안정성: 과부하 상황에서도 중요한 태스크의 실행을 보장해야 합니다.
5. 동기화 문제 해결: 우선순위 역전 문제를 해결해야 합니다.

### 질의응답
1. 경성 실시간 시스템과 연셩 실시간 시스템의 주요 차이점은 무엇인가요?
- 경성 실시간 시스템은 모든 태스크가 반드시 기한 내에 완료되어야 하며, 기한을 어기면 시스템 실패로 간주됩니다. 반면, 연서 실시간 시스템은 일부 기한 미준수를 허용하며, 기한을 어겨도 시스템이 계속 작동합니다. 경성 시스템은 안전 중심적이고, 연성 시스템은 성능 중심적입니다.
2. Rate Monotonic과 Earliest Deadline First 스케줄링의 차이점은 무엇인가요?
- Rate Monotonic은 정적 우선순위 알고리즘으로, 태스크의 주기에 기반하여 우선순위를 할당합니다. Earliest Deadline First는 동적 우선순위 알고리즘으로, 마감 시간이 갖아 가까운 태스크에 가장 높은 우선순위를 부여합니다. EDF는 일반적으로 CPU 이용률이 더 높지만, 구현과 런타임 오버헤드가 더 복잡할 수 있습니다.
3. 실시간 시스템에서 우선순위 역전 문제란 무엇이며 어떻게 해결할 수 있나요?
- 우선순위 역전은 높은 우선순위 태스크가 낮은 우선순위 태스크가 사용 중인 자원을 기다리는 상황입니다. 이는 시스템의 예측 가능성을 해칠 수 있습니다. 해결 방법ㅂ으로 우선순위 상송 프로토콜이나 우선순위 천장 프로토콜을 사용할 수 있습니다.

## 멀티프로세서 스케줄링
멀티프로세서 스케줄링은 여러 개의 프로세서(또는 코어)를 가진 시스템에서 프로세스를 효율적으로 분배하고 실행하는 방법을 다룹니다.
### 대칭형 멀티프로세싱 (SMP: Symmetric Multiprocessing)
- 특징
  - 모든 프로세서가 동등하게 취급됩니다.
  - 각 프로세서는 공통의 메모리와 I/O 버스를 공유합니다.
  - 하나의 운영체제가 모든 프로세스를 제어합니다.
- 스케줄링 방식
  - 공유 큐 접근법
    - 모든 준비 상태의 프로세스가 하나의 공유 큐에 저장됩니다.
    - 장점: 부하 균형이 자연스럽게 이루어집니다.
    - 단점: 큐에 대한 경쟁으로 인한 병목 현상이 발생할 수 있습니다.
  - per-processor 큐 접근법
    - 각 프로세서가 자체적인 준비 큐를 가집니다.
    - 장점: 큐 경쟁이 줄어들어 확장성이 좋습니다.
    - 단점: 부하 불균형이 발생할 수 있어, 부하 균형 메커니즘이 필요합니다.
- 주요 고려사항
  - 캐시 친화성: 프로세스를 이전에 실행되었던 프로세서에 다시 할당하여 캐시 히트율을 높입니다.
  - 부하 균형: 모든 프로세서가 비슷한 양의 작업을 수행하도록 합니다.
  - 병렬성 활용: 멀티스레드 애플리케이션의 스레드들을 효과적으로 분산시킵니다.

### 비대칭형 멀티프로세싱 (AMP: Asymmetric Multiprocessing)
- 특징
  - 프로세서들이 서로 다른 역할을 가집니다.
  - 주로 하나의 마스터 프로세서가 다른 프로세서들을 관리합니다.
  - 각 프로세서가 특정 작업에 특화될 수 있습니다.
- 스케줄링 방식
  - 마스터 프로세서가 작업을 다른 프로세서들에게 할당합니다.
  - 각 프로세서는 자신에게 할당된 특정 유형의 작업만 처리할 수 있습니다.
- 장단점
  - 장점: 특정 작업에 대해 높은 효율성을 얻을 수 있습니다.
  - 단점: 유연성이 떨어지고, 마스터 프로세서가 병목이 될 수 있습니다.

### 동적 스케줄링 vs 정적 스케줄링
#### 동적 스케줄링
- 런타임에 프로세스를 프로세서에 할당합니다.
- 시스템 상태에 따라 유연하게 대응할 수 있습니다.
- 오버헤드가 더 클 수 있지만, 변화하는 워크로드에 적응적입니다.

#### 정적 스케줄링
- 프로세스가 시작될 때 특정 프로세서에 고정됩니다.
- 오버헤드가 적지만, 부하 불균형이 발생할 수 있습니다.

### NUMA (Non-Uniform Memory Access) 아키텍처에서의 스케줄링
- 특징
  - 메모리 접근 시간이 프로세서와 메모리의 물리적 위치에 따라 다릅니다.
  - 로컬 메모리 접근이 원격 메모리 접근보다 빠릅니다.
- 스케줄링 고려사항
  - 메모리 지역성: 프로세스를 가능한 자주 사용하는 메모리와 가까운 프로세서에 할당합니다.
  - NUMA 인식 스케줄링: 메모리 접근 패턴을 고려하여 프로세스를 할당합니다.

### 질의응답
1. SMP와 AMP의 주요 차이점은 무엇인가요?
- SMP는 모든 프로세서가 동등하게 취급되고 공통의 작업 큐를 고유하는 반면, AMP는 프로세서들이 서로 다른 역할을 가지며 주로 마스터 프로세서가 다른 프로세서들을 관리합니다. SMP는 유연성이 높고 부하 균형이 쉽지만, AMP는 특정 작업에 대해 높은 효율성을 얻을 수 있습니다.
2. 멀티프로세서 환경에서 캐시 친화성이 중요한 이유는 무엇인가요?
- 캐시 친화성은 프로세스를 이전에 실행되었던 프로세서에 다시 할당함으로써 캐시 히트율을 높이는 것을 의미합니다. 이는 캐시 미스로 인한 메모리 접근 지연을 줄이고, 결과적으로 시스템 성능을 향상시킵니다. 특히 대규모 데이터를 다루는 프로셋에서 중요합니다.
3. NUMA 아키텍처에서 스케줄링의 주요 도전 과제는 무엇인가요?
- NUMA 아키텍처에서는 메모리 접근 시간이 프로세서와 메모리의 물리적 위치에 따라 다릅니다. 주요 도전 과제는 프로세스를 자주 사용하는 메모리와 가까운 프로세서에 할다하여 메모리 지역성을 최대화하는 것입니다. 또한, 부하 균형을 유지하면서 동시에 메모리 접근 효율성을 최적화해야 합니다.


## 질의응답
### 프로세스와 스레드의 차이점을 설명해주세요
프로세스는 실행 중인 프로그램의 인스턴스로, 독립적인 메모리 공간과 시스템 자원을 할당받습니다. 반면, 스레드는 프로세스 내에서 실행되는 더 작은 실행 단위입니다.
1. 메모리 공간: 프로세스는 독립적인 메모리 공간을 가지지만, 스레드는 같은 프로세스 내의 메모리를 공유합니다.
2. 자원 공유: 프로세스 간 자원 공유는 어렵지만, 같은 프로세스의 스레드들은 자원을 쉽게 공유합니다.
3. 컨텍스트 스위칭: 프로세스 간 전환은 비용이 크지만, 스레드 간 전환은 상대적으로 가볍습니다.
4. 생성 및 종료: 프로세스의 생성과 종료는 스레드에 비해 더 많은 시간과 자원을 필요로 합니다.
### CPU 스케줄링의 목적은 무엇이며, 주요 스케줄링 기준에는 어떤 것들이 있나요?
CPU 스케줄링의 주요 목적은 시스템 자원을 효율적으로 사용하고, 사용자와 시스템의 요구사항을 만족시키는 것입니다.
1. CPU 사용률: CPU가 유휴 상태에 있는 시간을 최소화합니다.
2. 처리량: 단위 시간당 완료되는 프로세스의 수를 최대화합니다.
3. 대기 시간: 프로세스가 준비 큐에서 대기하는 시간을 최소화합니다.
4. 응답 시간: 요청 후 첫 응답이 나오기까지의 시간을 최소화합니다.
5. 공정성: 모든 프로세스가 적절한 CPU 시간을 할당받도록 합니다.
### 선점형 스케줄링과 비선점형 스케줄링의 차이점과 각각의 장단점을 설명해주세요.
선점형 스케줄링은 운영체제가 실행 중인 프로세스로부터 강제로 CPU를 빼앗아 다른 프로세스에게 할당할 수 있는 방식입니다. 비선점형 스케줄링은 프로세스가 자발적으로 CPU를 반환하거나 작업을 마칠 때 까지 계속 실행되는 방식입니다.
- 선점형 스케줄링
  - 장점
    - 높은 우선순위 프로세스의 빠른 응답 가능
    - 시분할 시스템 구현에 적합
  - 단점
    - 잦은 컨텍스트 스위칭으로 인한 오버헤드
    - 동기화 문제 발생 가능
- 비선점형 스케줄링
  - 장점
    - 컨텍스트 스위칭 오버헤드가 적음
    - 구현이 간단하고 예측 가능성이 높음
  - 단점
    - 긴 작업이 시스템을 독점할 수 있음
    - 실시간 시스템에 부적합
### 다단계 피드백 큐 스케줄링 알고리즘에 대해 설명해주세요
다단계 피드백 큐는 여러 개의 준비 큐를 사용하며, 각 큐는 다른 우선순위와 시간 할당량을 가집니다. 
프로세스는 동작 특성에 따라 큐 사이를 이동할 수 있습니다.
- 주요 특징
  - 여러 개의 큐: 각 큐는 다른 우선순위를 가지며, 상위 큐일수록 우선순위가 높습니다.
  - 동적 우선순위: 프로세스의 CPU 버스트 특성에 따라 큐 사이를 이동합니다.
  - 에이징: 낮은 우선순위 큐에서 오래 대기한 프로세스의 우선순위를 점진적으로 높입니다.
- 장점
  - 다양한 유형의 프로세스를 효율적으로 처리할 수 있습니다.
  - I/O 중심 프로세스와 CPU 중심 프로세스를 구분하여 처리합니다.
  - 시스템의 전반적인 성능을 향상시킬 수 있습니다.
- 단점
  - 구현이 복잡하고 오버헤드가 있을 수 있습니다.
  - 매개변수 설정이 시스템 성능에 큰 영향을 미칩니다.
### 실시간 스케줄링엣 경성 실시간 시스템과 연성 실시간 시스템의 차이점은 무엇인가요?
경성 실시간 시스템과 연성 실시간 시스템의 주요 차이점은 다음과 같습니다.
- 경성 실시간 시스템
  - 모든 태스크가 반드시 정해진 기한 내에 완료되어야 합니다.
  - 기한을 어기면 시스템 실패로 간주되며, 심각한 결과를 초래할 수 있습니다.
  - 예: 비행기 제어 시스템, 의료 장비
- 연성 실시간 시스템
  - 대부분의 태스크가 기한 내에 완료되어야 하지만, 일부 기한 미준수가 허용됩니다.
  - 기한을 어겨도 시스템이 계속 작동하며, 성능 저하만 발생합니다.
  - 예: 스트리밍 미디어 시스템, 온라인 게임

경성 실시간 시스템은 예측 가능성과 신뢰성이 매우 중요하며, 최악의 경우 실행 시간을 고려하여 설계됩니다. 반면, 연성 실시간 시스템은 평균 성능이 중요하며, 일부 지연이 허용됩니다.
